<!-- $Id$ -->
<chapter id="emulatorer">
<title>Emulatorer</title>
<indexterm><primary>win4lin</primary></indexterm>
<indexterm><primary>Plex86</primary></indexterm>
<indexterm><primary>Emulator</primary><secondary>VMware</secondary></indexterm>
<indexterm><primary>Emulator</primary><secondary>SCO</secondary></indexterm>

<para>
En emulator er et program, som gør det muligt at afvikle programmer
skrevet til en anden computer eller styresystem. Vi vil i dette afsnit 
se på en række forskellige emulatorer, som du kan benytte under Linux.
</para>

<para>
Med hensyn til emulatorer kan Linux køre SCO programmer
(en kommerciel Unix-variant) gennem det, der hedder iBCS biblioteket (Intel
Binary Code Standard). Dette giver adgang til en del ekstra
kommercielle database-programmer. 
</para>

<para>
Har du en kraftig (gerne 128 MB RAM) og hurtig PC (gerne mere end 266
MHz Pentium II), kan du <emphasis>købe</emphasis> VMware, som laver en
emuleret processor og kobling til maskinen.  Så kan du køre dine
Windows-programmer samtidig med, at du kører dine Linux-programmer -
og principielt kan alle programmer køre. VMware kræver naturligvis, at
Windows er installeret på computeren.  VMware findes på <ulink
url="http://www.vmware.com">http://www.vmware.com</ulink>
</para>


<para>
Et alternativ er <command>win4lin</command>, som også er på vej
frem. Denne kan købes fra <ulink
url="http://www.netraverse.com">http://www.netraverse.com</ulink>.
Win4lin kræver umiddelbart langt færre ressourcer end VMware, men har
også et par begrænsninger, såsom at kerne 2.4 ikke understøttes, der
findes ingen "network neighborhood", man skal sambamounte (eller nfs)
mounte netværksdrev, før man starter <command>win4lin</command>, og i
en tabel til <command>win4lin</command> angive, hvordan drevbogstaver
mappes. Dette vil være noget i retning af: C: Mappes til
<filename>/home/bruger/win</filename> M: Mappes til
<filename>/nfs/server/directory</filename> etc. Hukommelse kan
tildeles til Windows fra 20MB op til max. 64MB.  Der er også
begrænsninger i den grafik, der kan understøttes.
</para>

<para>
Hvor VMware og win4lin er kommercielle pakker, så er et frit projekt
<command>Plex86</command> på vej. Dog er det endnu ikke anvendeligt
og er ekstremt langsomt.
</para>


<FIGURE ID="fig-win4lin" FLOAT="1">
<TITLE>Windows kører under Linux via Win4lin</TITLE>
<GRAPHIC FILEREF="win4lin.&magic;"  SCALE="40"></GRAPHIC>
</FIGURE>


<sect1 id="vmware">
<title>Vmware - flere maskiner i en</title>
<indexterm><primary>VMware</primary></indexterm>
<para>
Du kan med programmet VMware (<ulink
url="http://vmware.com">http://vmware.com</ulink>) sætte din maskine
op til at køre flere styresystemer samtidigt. Du kan hente en 30-dages
licens til systemet hos <ulink
url="http://vmware.com">http://vmware.com</ulink>, (og tilsyneladende
forny den en del gange senere, ikke mindst hvis du har en
*.mail;). Samme sted findes en meget fyldig og logisk opdelt
installationsvejledning, som efter et par dages eksperimenter oven i
købet er til at forstå.
</para>

<sect2 id="vmware-fordele">
<title>Fordele ved virtuelle maskiner</title>

<para>
Med de virtuelle maskiner opnår du flere fordele.Samme hardware til
alle styresystemer uanset antal. Jeg har en vane med at bruge
udrangeret udstyr i en junkmaskine til at lege med, men det er ikke
tilfredsstillende at gå fra fx. 850MHz PIII til 333 Mhz PII.Mulighed
for at suspendere maskiner uden at skulle gennem en boot næste gang de
skal bruges.Muliged for at afteste netværks-programmer uden at skulle
investere en formue i hardware.Mulighed for at lege med nye
distributioner uden at ødelægge den kørende server.  (Der skal nok
være flere gode grunde, men disse var nok til at få mig til lommerne).
</para>

<para>
Selv om du kan sætte en server op i en virtuel maskine til permanent
brug, skal du ikke gøre dette. Virtuelle maskiner er efter min mening
kun velegnet i forbindelser med aftestning. Selv en ældre maskine med
en installeret server (ikke virtuel) er bedre, og så er du også fri
for at få opsætningen på denne maskine forstyrret.
</para>
</sect2>


<sect2 id="vmware-hardwarekrav">
<title>Hardwarekrav</title>

<para>
Det kan stærkt anbefales at afprøve programmet for at se, om det kan
hvad man ønsker, og om ens hardware er hurtig nok til at give et
tilfredsstillende resultat. Ens processor bør efter min mening være
CPU >= 600 Mhz, RAM >=128MB og harddisken skal have 2-4 GB plads
pr. virtuel maskine.
</para>

</sect2>

<sect2 id="vmware-vaert">
<title>Valg af værtssystemet</title>

<para>
Ideen med programmet er, at du først installerer dit HOST-styresystem
(Linux, NT4 eller Win2K), og derefter opretter en eller flere
virtuelle maskiner under dette host-system, hvori du installerer andre
(eller samme) styresystem. Installerer du MS eller andre
købe-styresystemer, skal du naturligvis have licens til dem, mere
virtuelt er det trods alt ikke.
</para>

<para>
Det første valg du skal gennemtænke meget grundigt er, hvilket
styresystem der skal være på maskinen (HOST).
</para>

<para>
Det du skal lægge vægt på her er både hvad du normalt bruger din
maskine til, og om al din hardware (også den kommende) er understøttet
af styresystemet. Begge grunde fik mig til at vælge W2K som HOST, da
jeg dels primært arbejder i Delphi, og dels har en hang til mystisk
(ofte alt for dyr) hardware.
</para>

<para>
Den næste overvejelse er hvilke styresystemer, der skal installeres
som GUEST-systemer. Her er valget langt lettere, idet du kan have alt
der vedrører en given virtuel maskine liggende samlet i en folder ( et
dir ), som blot kan slettes, hvis du valgte noget forkert. Du kan
naturligvis også vælge at lade den virtuelle maskine som sådan
overleve, og blot installere noget andet forfra. Det du risikerer ved
fejlvalg er således blot at opsamle unyttige erfaringer, men det kan
jo også have en værdi.
</para>
</sect2>

<sect2 id="vmware-pre-installation">
<title>Inden installationen</title>

<para>
Det er meget vigtigt, at du starter med at installere netværksdrivere
i dit HOST-system umiddelbart efter, du har installeret Vmware selv,
og inden du begynder at installere virtuelle maskiner. Har du ikke
dette på plads, vil du hurtigt løbe ind i problemer med at kommunikere
mellem systemerne. Jeg valgte at installere driveren til
Bridget-networking, hvilket senere giver adgang til at gøre de
virtuelle maskiner offentligt tilgængelige. Du kan som alternativ
vælge et lukket netværk, som alene giver adgang til at kommunikere
internt mellem host/guest systemer.
</para>

<para>
En anden ting, der skal være på plads er skærmens farvedybde. 16 og 24
bit fungerer ganske enkelt ikke. 8 bit giver hurtigere maskiner rent
grafisk, mens 32 giver flottere udseende.
</para>

<para>
Under W2K kan det være praktisk at tilpasse den indbyggede DHCP
servers adresseområde. Jeg har valgt at køre alt under 192.168.1.* og
har derfor tilpasset filen
<filename>C:\WINNT\System32\vmnetdhcp.conf</filename>, så der uddeles
adresser i det område:
</para>

<screen>
subnet 192.168.1.0 netmask 255.255.255.0 {
    range 192.168.1.210 192.168.1.220;
    option broadcast-address 192.168.1.255;
    option domain-name-servers 192.168.1.200;
    option domain-name "linux.intranet";
}
</screen>

<para>
Er det en Windows-host, gør det heller ingen skade at køre en
defragmentering på harddisken, så der kommer en sammenhæng i de
datafiler, de virtuelle maskiner skal "leve" I.
</para>
</sect2>

<sect2 id="vmware-deling">
<title>Deling af filer mellem styresystemerne</title>
<para>
Installerer du win9x på en maskine med NT/W2K som host, er
delingsmulighederne via en workgroup helt som mellem de to
styresystemer på to uafhængige maskiner.
</para>

<para>
Har du Linux med i spil, skal du sætte samba op på den, og arbejde med
filflytning fra Windows siden. Altså 
</para>

<para>
<emphasis>Linux-Host + Win9X/NT4/W2K guest:</emphasis> Her skal Linux
have samba installeret, og i den/de virtuelle maskiner kan du derefter
kopiere til/fra samba-"drevene".
</para>

<para>
<emphasis>NT/W2K-host + Linux-guest:</emphasis> 
Igen her skal samba
ind på Linuxmaskinen, og du kan fra Hosten hente og gemme filer på
samba-"drevene". Det vil ikke være praktisk at lave en permanent
mapning, da Windows maskinen jo ikke kan finde den virtuelle samba før
den er sat i gang.
</para>

<para>
Har du en selvstændig Linux-server, kan dens samba-"drev" bruges som
fælles drev for både host og guest systemerne. Dette vil være den
foretrukne løsning for de fleste med en linuxserver, da de filer, der
ligger på serveren jo ikke er så udsat for at gå tabt ved et
systemnedbrud.
</para>

<para>
Der er andre muligheder for fildeling, men disse forekommer mig at
være de mest enkle at håndtere, ikke mindst fordi de allerede er
implementeret mellem min Linux-server og W2K arbejdspladser.
</para>

</sect2>

<sect2 id="vmware-skaerm">
<title>Skærmopløsning</title>
<para>
Dette emne er meget hardwareafhængigt. Jeg kører med et Matrox Marvel
G400 TV kort som har diverse forskellige muligheder for
opløsninger. Mit valg har været at sætte værten op til 1152x864, mens
gæsterne kun kører i 1024x768. Dette giver plads til at vise gæsterne
i (virtul) fuld skærm, og dog tillade overskrift og menulinie omkring
dem. Matrox-kortet understøtter desuden virtuelle skærme, så hver af
de virtuelle maskiner kan få sin egen skærm at brede sig i.
</para>

<para>
Andre, nyere skærmkort tillader lignende løsninger.
</para>

<para>
Der kan opstå lidt problemer med opdateringen af skærmene i de
virtuelle maskiner, men jeg tilskriver dem mere Matrox-driveren end
VMware.
</para>
</sect2>

<sect2 id="vmware-reboot">
<title>Reboot/Power off/Suspend</title>
<para>
Det er kun i forbindelse med installationer, at man har behov for at
"slukke" for den virtuelle maskine. Normalt vælger jeg blot at
suspendere den. Det er ganske enkelt herligt at have en fuldt
installeret, kørende SuSE/KDE/Konqueror oppe på under 5 sekunder med
/etc vist med et hav af små ikoner. Det tager omtrent 4 minutter at
lave en boot på min maskine (den har SCSI), så den med at dual-boote
dur ganske enkelt ikke i dagligt brug.
</para>

<para>
ALT+CTRL+DEL fanges af værten, mens ALT+CTRL+INS oversættes til en
lokal ALT+CTRL+DEL i den af de virtuelle maskiner der har focus. En
både sjov og logisk løsning, som man går fejl af en del gange i
starten.
</para>

<para>
Med W2K som host giver ALT+CTRL+DEL i en virtuel maskine den
sædvanlige logout dialog, men selv ved valg af CANCEL i denne dialog
ryger tastetrykket ALT+CTRL+DEL til den virtuelle maskine, som
reagerer på det. Det er det man sædvanligvis er interesseret i, så det
kan vel knapt kaldes mere end en skønhedsfejl. Kører den virtuelle
maskine X får man her en mulighed for at fortryde, kører den i en
tekst-konsol, går den i gang med en "reboot -n" uden videre.
</para>
</sect2>

<sect2 id="vmware-focus">
<title>Focus/prioritet</title>
<para>
VMware "grabber" focus enten ved et bestemt tastetryk eller ved et
klik med musen i den virtuelle maskines vindue. Jeg har valgt kun at
bruge musen, det fungerer overbevisende. Man slipper fri igen med
CTRL+ALT+ESC, hvorefter focus er placeret i hostmaskinen. Skiftes der
til full-screen modus er det ligeledes CTRL+ALT+ESC der skal anvendes
for at slippe fri.
</para>

<para>
Der er mulighed for at bestemme, hvordan maskinens ressourcer skal
fordeles mellem de kørende virtuelle maskiner. Normalt vil det være at
foretrække med en høj prioritet til den maskine, der har focus, og en
lavere til de øvrige. Ressource-prioriteringen kan ændres under drift.
</para>

<para>
Der er mulighed for at tildele større eller mindre mængder RAM til de
virtuelle maskiner. Denne mængde kan der kun ændres på, når den
virtuelle maskine er helt slukket (ikke under suspend, de færreste
styresystemer kan håndtere hot-swap-RAM:).
</para>

<para>
Det er (heldigvis) ikke muligt at starte samme virtuelle maskine op i
flere kopier.
</para>
</sect2>

<sect2 id="vmware-flere">
<title>Flere ens virtuelle maskiner</title>
<para>
Hvis du har fulgt rådet i starten af dette dokument om at installere
hver virtuel maskine i sin egen folder (katalog), kan du endog meget
hurtigt sætte en række ens virtuelle maskiner op. Start med at
installere den første maskine.Luk den virtuelle maskine ned (ellers
vil kopien starte med at køre check på disken). Kopier folderen med
indhold til en ny folderRet sti og evt filnavne i
<filename>.vmx</filename> filen vha. en simpel teksteditor.
</para>

<para>
Nu har du fået to eller flere ens virtuelle maskiner, og kan blot
starte dem fra en ende af. Du skal dog være opmærksom på, at fysiske
enheder og COM-porte kan give konflikt ved start af flere virtuelle
maskiner, som alle ønsker at starte med fx. drev A:
"connected". Vmware løser denne konflikt ved at sætte sådanne enheder
til ikke at være forbundet ved boot. De kan derefter aktiveres efter
behov under drift.
</para>
</sect2>

<sect2 id="vmware-vnc">
<title>Vmware og VNC</title>

<para>
Det er rent faktisk muligt at afvikle virtuelle maskiner via VNC (se
også <xref linkend="vnc">). Hvis hosten kører vncserver + en virtuel
maskine, kan man bearbejde den virtuelle maskine via sin
vnc-forbindelse. Det giver dog en del mere mening at starte vncserver
på både host og den/de virtuelle maskiner, da "oversættelsen" fra
virtuel til host til vnc er alt for sløv.
</para>

<para>
Altså: Installer og start vncserver på alle de virtuelle
maskiner. Kører den virtuelle maskine Linux, kan du uden videre
minimere den, da vnc alligevel ikke bruger det viste skærmbillede.
</para>

<para>
Brug vncviewer til at vise hver enkelt maskine.
</para>

<para>
Dette dokument skives på en bærbar maskines tastatur en stille
sommeraften på terassen via vnc til min normale arbejdsplads, som
forøvrigt kører to win98 og en enkelt SuSE 7.0 i virtuelle
maskiner. Linux'en kører minimeret på sin host, men i et andet
vnc-view på den bærbare, mens min normale Linux-server blot for en
ordens skyld kører i et tredje view.
</para>

<para>
Alle maskiner kører med en tilfredsstillende hastighed, faktisk er
alle en del hurtigere at arbejde på, end hvis jeg havde arbejdet
direkte på den bærbare.
</para>
</sect2>

<sect2 id="vmware-vnc-problem">
<title>Det største problem</title>
<para>
Det største problem ved virtuelle maskiner er efter min mening at
finde rundt i dem. Man kan opnå en del ved at lave skrivebordet
forskelligt, både i baggrundsfarve og placering af diverse
paneler. (Her har jeg for første gang fundet en nyttig grund til at
skifte baggrundsfarve;)
</para>

<para>
Vænner man sig til aldrig at slukke, men kun "suspende" de virtuelle
maskiner er meget nået mht. utilsigtet afbrydelse.
</para>
</sect2>

<sect2 id="vmware-konklusion">
<title>Konklusion</title>
<para>
VMware er et af de programmer, der på trods af mange års arbejde
indenfor EDB-området, har fået mig til at hæve et øjenbryn i
(blaseret) begejstring. For første gang siden mit første møde med ægte
multitasking i OS2, er der noget der rykker. Jeg har i mange år haft
elektronisk omskiftning mellem fire maskiner til samme
tastatur/skærm/mus, og er vant til at kunne skifte let mellem dem, men
fleksibiliteten i at kunne se alle samtidigt, og at kunne skifte
mellem dem med et klik er virkelig et fremskridt.
</para>

<para>
Det sker kun en sjælden gang, at min CPU arbejder 100%. Delingen af
processorkraften mellem flere maskiner er derfor ikke noget, der i
større grad generer. Dette sammenholdt med den virkning, at alle
maskiner opdateres samtidigt og gratis, hver gang min host-maskine
ombygges eller udvides, gør programmet særdeles interessant. Selv om
skattefar mod- og ufrivilligt sponsorerer to trediedele af mine
nyanskaffelser er der jo trods alt den sidste trediedel at tage hensyn
til.
</para>
</sect2>
</sect1>


<sect1 id="dosemu">
<title>DOS-emulatoren dosemu</title>
<indexterm><primary>DOS</primary><secondary>emulering, dosemu</secondary></indexterm>
<indexterm><primary>Emulator</primary><secondary>dosemu, FreeDOS</secondary></indexterm>

<para>
Mangler du specifikke DOS-programmer under Linux, kan du få en
DOS-emulator (<command>dos</command> (konsol-orienteret) og
<command>xdos</command> (X-baseret)), således at du under Linux kan
køre DOS-programmer. Programmet kan sågar køre grafikprogrammer
(f.eks. Windows 3.1) - dog ikke nyere Win32 programmer. Du kan
f.eks. anvende DOS-emulatoren til at køre Gyldendals røde ordbøger.
</para>

<para>
DOS-emulatoren består egentlig af to dele. Den ene del gør det muligt
at køre DOS-programmer under Linux, mens den anden del er selve
styresystemet DOS. Der følger en DOS ved navn FreeDOS med, men du kan
i princippet bruge din egen, f.eks. hvis du en gang har købt DOS og
stadig har installationsdisketterne liggende. I det følgende vil vi
dog kun benytte FreeDOS. Begge dele er indeholdt i dosemu-pakken.
</para>

<para>
Lad det være sagt med det samme: den version af DOS-emulatoren, som
følger med Red Hat virker <emphasis>ikke</emphasis>. Grunden er
den simple, at Red Hat har valgt at benytte den nyeste version. Men
denne version er for udviklerne, dvs. den er fuld af fejl og
mangler. Derfor skal du først nedgradere dit system til den stabile
version. Nedenfor ser du, hvordan du gør det.
</para>

<screen>
<prompt>[root@linus root]# </prompt><userinput>rpm -e dosemu-freedos-0.99.10-4</userinput>
<prompt>[root@linus root]# </prompt><userinput>rpm -e xdosemu-0.99.10-4</userinput>
<prompt>[root@linus root]# </prompt><userinput>rpm -e dosemu-0.99.10-4</userinput>
<prompt>[root@linus root]# </prompt><userinput>rpm -i dosemu-0.98.8-1.i386.rpm</userinput>
</screen>

<para>
Filen <filename>dosemu-0.99.8-1.i386.rpm</filename> kan du hente fra <ulink
url="http://www.dosemu.org/">http://www.dosemu.org/</ulink>.
For at få DOS-emulatoren til at virke skal du have DOS installeret.
Nedgraderer du som anvist ovenfor, kan du let få en gratis DOS (FreeDOS). Du
skal blot omdøbe filen <filename>hdimage.first.rpmsave</filename> i
kataloget <filename>/var/lib/dosemu</filename> til
<filename>hdimage.first</filename>.
</para>

<screen>
<prompt>[root@linus root]# </prompt><userinput>cd /var/lib/dosemu </userinput>
<prompt>[root@linus dosemu]# </prompt><userinput>mv hdimage.first.rpmsave hdimage.first</userinput>
</screen>

<para>
Eftersom du under DOS kan rode direkte med hardware (som du ikke som
almindelig bruger under Linux kan), kan kun root køre
DOS-emulatoren. Hvis du ønsker at ændre dette, skal du rette i filen
<filename>/etc/dosemu.users</filename>. Den RPM-fil, som du har
installeret som anvist ovenfor, tillader at alle bruger den, så du skal
ikke rette noget.
</para>

<para>
Under en standard installation af dosemu-pakken oprettes et billede
af en harddisk. Billedet emulerer C-drevet. Dette billede finder du
(under Red Hat 6.0) som
<filename>/var/lib/dosemu/hdimage.first</filename>. Det er let at
hente og gemme filer på dette billede fra Linux. Du skal blot føje
linjen 
<screen>drive g:  file="/var/lib/dosemu/hdimage" Offset=8832</screen> 
til <filename>/etc/mtools.conf</filename>, og nu 
kan du bruge <command>mcopy</command>, <command>mdir</command> osv.
</para>

<para>
Vil du vide mere om DOS-emulatoren, er <ulink
url="http://www.dosemu.org">http://www.dosemu.org</ulink> et godt sted 
at begynde. FreeDOS finder du på <ulink
url="http://www.freedos.org">http://www.freedos.org</ulink>
</para>

<FIGURE ID="fig-dosemu" FLOAT="1">
<TITLE>WordPerfect 5.1 i DOS-emulatoren</TITLE>
<GRAPHIC FILEREF="wp51-dosemu.&magic;"  SCALE="40"></GRAPHIC>
</FIGURE>
</sect1>

<!-- Skrevet af Mikkel Maastrup -->
<sect1 id="WINE">
<title>Kør Windows programmer med WINE</title>
<indexterm><primary>Wine</primary></indexterm>
<para>
WINE står for "Wine Is Not an Emulator" og det er et program det
tillader dig at køre MS-DOS- og Windows-programmer under X på enhver
Linux-distribution (og andre UNIX-systemer som f.eks. FreeBSD og
Solaris). Der er endda nogle som er gået i gang med at portere det til
endnu flere operativ systemer som f.eks. BeOS. Som navnet siger er
WINE ikke en emulator og kan derfor kun køre på de Intel x86-baserede
computere (altså ikke på Linux-systemer til f.eks. Macintosh). Mange
hundrede programmører har sørget for at WINE er blevet til. WINE
sørger får at Windows-programmerne virker som om de var lavet til
Linux. Man kan altså f.eks. klippe/klistre mellem et program der
bliver kørt af WINE og så et "normalt" Linux program. WINE er skrevet
i programmeringssproget C og har en frit tilgængelig kildekode (som så
meget andet Linux-software), og det gør bl.a. at alle kan hjælpe til
med at udvide og rette i programmet.  
</para>

<para>
WINE kan faktisk køre
Windows-programmer på Linux uden at have Windows installeret på
computeren. Hvis man har Windows vil WINE dog være i stand til benytte
originale systemfiler og dermed give bedre ydelse. Med WINE følger der
også noget som kaldes Winelib hvilket gør at man kan kompilere sine
Windows- kildekoder til Linux- software. Altså, hvis man har lavet et
Windows-program og har kildekoden, så kan man altså bare oversætte
programmet med en Linux-compiler i stedet for en Windows-compiler (så
softwaren dermed virker til Linux også). Det er der nogle store
firmaer der har gjort. Bl.a. Corel. Alle Corels Linux produkter
benyttede sig altså af WINE, og det gør de vist stadig. Det er dog
ikke perfekt så der skal ofte ekstra arbejde til at tilpasse
programmet før det kan lade gøre.
</para>

<sect2 id="hvordan-wine">
<title>Hvordan virker WINE?</title>

<para>
Det sørger som sagt for at man kan køre Windows-programmer, og uden at
have Windows på computeren. Inden vi fortsætter skal vi lige se lidt
på de såkaldte API'er. API står for "Application Program
Interface". Når et program kører sender det såkaldte "API calls" til
det styrersystem det bliver kørt på. Et program kan altså gøre brug af
af API'er på det operativ sytem det bliver kørt på. F.eks. kan et "API
call" være at skrive en fil på en harddisk eller sende output til en
printer. Hvert opereativ system har hver deres "API calls". Det som
WINE gør er at gå ind og ændre Windows API'erne til Linux API'er. Så
når et Windows-program sender en "Windows-API" gennem WINE, så modtager
Linux en "Linux API" der har den samme funktion som det API'en burde
have gjort på Windows. Programmet tror altså at det kører på Windows
og Linux tror det modtager informationer fra et Linux-program. Det
som WINE, meget enkelt forklaret, gør er at den starter to
programmer. Det ene er et specielt program der gør at man kan starte
Windows-programmet og det andet er et program som omdanner Windows
API'erne til Linux API'er. Det er det WINE går ud på. Altså at omdanne
Windows' API-sæt til Linux' API-sæt. Enhver som har prøvet WINE ved
dog at det er langt fra alle programmer som kan kører via det. Og
hvordan kan det være? Det er fordi Windows ikke er Open Source
software og derfor kan ingen bare gå hen og finde Windows API'erne i
kildekoden. Dokumentationen til Win32 API kald er heller ikke spor
god og er blevet kritiseret for at være ikke-eksisterende, sparsom og
endda vildledende. WINE-folkenes arbejde er derfor mest baseret på
gæt. Win16 og DOS API kald skiftes ikke længere ud. Derfor vil
langt de fleste af gamle Windows-programmer virke via WINE. Win32
kald skifter dog stadigvæk og hvis Microsoft introducerer et nyt
sæt API kald eller ændrer på dem som findes i forvejen så skal dette
jo også tilføjes. Derfor bliver WINE formodentlig aldrig færdig. Selv
om det startede i 1993 så er der ikke kommet en stabil version
endnu.  
</para>
</sect2>

<sect2 id="wine-historie">
<title>Lidt historie</title>

<para>
WINE-projektet startede i 1993 på Usenet newsgroupen
comp.os.linux. Det var en fyr der hed Eric Youngdale som startede
det. I 1994 blev posten som koordinator for projektet overgivet fra
Bob Amstadt til Alexandre Julliard (som stadig sidder på
posten). Grunden til at WINE-projektet blev startet var (og er stadig)
at langt det meste software bliver udviklet til Windows. Man ønskede
altså at have adgang til den kæmpe mængde software som er blevet lavet
til Windows og samtidig have glæde af Linux' fordele.
</para>

<para>
WINE er stadig ikke færdig så det er ikke alle programmer som kan
kører via WINE. De fleste ældre programmer burde dog virke.
</para>
</sect2>


<sect2 id="wine-installation">
<title>Installation af WINE</title>
<para>
For at installere det har jeg valgt at bruge WINE Preview 3 fra
firmaet Codeweavers. Dette er en helt normal WINE udgave som blot er
blevet pakket fint ind, så den nu har grafisk installation og
konfiguration.
</para>

<para>
Codeweavers WINE findes kun som .rpm-fil (på <ulink
url="http://www.codeweavers.com">http://www.codeweavers.com</ulink>). Hvis
du bruger bruger RedHat, Mandrake og SuSE (samt en del flere) kan du
bruge denne udgave af WINE. Hvis du kører med en
"ikke-rpm"-distribution, som f.eks. Debian, skal du dog prøve at se på
<ulink url="http://www.winehq.com">http://www.winehq.com</ulink> efter
en Debian version af WINE.
</para>

<para>
Når du installerer Codeweavers WINE så burde den kunne bruge tidligere
WINE-konfigurationer og installerede Windows-programmer. Jeg er dog
ikke sikker på om det går lige godt hver gang, selvom der indtil
videre ikke har været nogle problemer for mig (man ved jo aldrig hvad
der kan ske). Derfor bør du passe ekstra godt på når du installerer
(Codeweavers) WINE hvis du i forvejen bruger WINE. Du kan risikerer at
bruge WINE uden at vide det. F.eks. bruger mange (hvis ikke alle) af
Corels Linux-programmer WINE. Som sagt er dette blot en vejledning som
følger den metode som jeg brugte. Jeg tager derfor intet ansvar hvis
noget skulle gå galt på din maskine, der har dog ikke været nogle
store problemer for mig indtil videre. Jeg vil i denne
installationsvejledning fortælle hvordan du kan installere WINE. Jeg
antager at du ikke tidligere har brugt WINE, at du er logget ind som
brugeren anne (dette navn skal du bare erstatte med dit eget
brugernavn), at du bruger en ".rpm-baseret" distribution og at du ikke
har en Windows-partition på din computer. 
</para>

<para>
Jeg har lavet denne vejledning på en Mandrake 8.0 distribution
så hvis du bruger en anden distribution end den kan der godt være
nogle ting som er lidt anderledes. Det skal jeg dog nok gøre dig
opmærksom på når det kommer.
</para>

<sect3 id="wine-installation-krav">
<title>Hvad kræver WINE af computeren?</title>

<para>
For at køre WINE skal duminimum have en computer med en
386-processor. Det er som sagt kun muligt at køre WINE på Intel
x86-processorer (altså normale PC'er) og dermed IKKE på computere som
Macintosh.
</para>

<para>
Et UNIX-operativ system som f.eks. Linux, FreeBSD, Solaris x86. Dog
skal man huske på at Codeweavers WINE kun kommer som .rpm-fil.
Minimum 16 MB ram. For virkelig at få noget ud af det anbefales
minimum 64 MB ram.
</para>

<para>
Et X11 window system (f.eks. XFree86). Hvis du benytter andet end
XFree86 kan det være lidt problematisk. Hvis det er tilfældet så se på
WINE's web-site.
</para>
</sect3>

<sect3 id="wine-hent">
<title>Få fat på programmet</title>

<para>
På <ulink url="http://www.codeweavers.com/technology/wine/download.php">http://www.codeweavers.com/technology/wine/download.php</ulink> henter du
pakken med WINE Preview 3 (den på ca. 12 MB. Altså der der hedder
"Installable Package") og lægger den ind i annes hjemmemappe
(/home/anne).
</para>
</sect3>

<sect3 id="wine-i-forvejen">
<title>Er der WINE i forvejen?</title>
<para>
Først skal du finde ud af om der i forvejen ligger en version af WINE
på din maskine. Det kan der godt gøre selv om du ikke ved det, for
nogle distributioner installerer det automatisk sammen med alt det
andet software. For at finde ud af det skal du skrive <command>rpm -qa
| grep wine</command> (evt. også <command>rpm -qa | grep
WINE</command>) i et terminalvindue. Hvis der er installeret en
version af WINE i forvejen bør du få et svar som minder lidt om det
her: <literal>wine-20010305-1mdk</literal>. Det er kun hvis du har en Mandrake
distribution at der står "mdk" til sidst. Der kan være mere end en
pakke hvis du f.eks. har en programmørudgave liggende også. Hvis du
har det bør du dog overveje om det er værd at skifte WINE ud.
</para>

<para>
WINE bliver opdateret utrolig tit og en version af WINE der følger med
din distribution kan godt være lidt gammel. Hvis du støder ind i et
problem med den version der ligger der i forvejen så kan det nogle
gange betale sig at opdatere WINE til den nyeste version. Hvis WINE
derimod virker fint til det formål du skal bruge det til, så er der jo
ingen grund til at fjerne det.
</para>

<para>
Hvis der intet står på skærmen efter et stykke tid så har du ikke WINE
installeret. Hvis det ikke er installeret så spring videre til
"Installation"-afsnittet.
</para>
</sect3>

<sect3 id="wine-afinstallation">
<title>Afinstallering</title>
<para>
Lad os se nærmere på hvordan man afinstaller WINE. Dette gøres ved at
logge ind som root og åbne en xterm eller åbne en xterm som ens
normale bruger og skrive su og trykke på enter-tasten og så skrive sit
root-kodeord.
</para>

<para>
Derefter skriver du <command>rpm -e programnavnet-fra-før</command> (i
mit tilfælde <command>rpm -e wine-20010305-1mdk</command>). Hvis du
har mere end en WINE-pakke så gør du bare det samme igen ved at skrive
<command>rpm -e navnet-på-det-andet-program</command>. Nu kan du så
igen skrive <command>rpm -qa | grep wine</command> (og <command>rpm
-qa | grep WINE</command>) og hvis der ingen ting kommer frem på
skærmen (udover en ny linie i konsollen) så er du WINE-fri.
</para>
</sect3>

<sect3 id="wine-ny-installation">
<title>Installation af ny WINE</title>
<para>
Det første du skal gøre er at (hvis du ikke længere har root-adgang så
skriv <command>su</command>, og derefter dit root-kodeord, i en xterm)
gå ind i mappen hvor WINE-pakken ligger med kommandoen <command>cd
/home/anne</command>. Her skriver du så <command>rpm -i
codeweavers-wine-20010305-1.i386.rpm</command>.
</para>

<para>
Nu kan der ske to ting. Enten så installerer den perfekt eller også så
fortæller den at den mangler nogle programmer for at kunne
installere. Den kan f.eks. skrive at den mangler programmet iTcl ellel
xmessage eller lignende. Det er så nødvendigt at skaffe pakkerne. Hvis
du har Mandrake 8.0 så kan du bruge deres Software Manager eller kan
du gå på Internettet og finde dem. iTcl pakkerne kan du finde på
CodeWeavers web-site. Hvis WINE skriver at du har brug for xmessage så
skal du installere pakken X11R6-contrib eller X11R6-contribs.
</para>

<para>
Når det så er installeret skal du logge ud af root og logge ind som
din normale wine-bruger. Nu skal du så konfigurere WINE. Det gøres via
WineSetup. WineSetup kan enten startes fra system-menuen eller fra
konsollen, det gør ingen forskel. Hvis du vil starte det fra konsollen
skal du bare skrive winesetup i en xterm. Så kommer der et vindue frem
hvor der er en tegning af Tux der prøver at åbne en vin. Her vælger du
den øverste valgmulighed. Den der hedder
<filename>~/.wine/config</filename> (new, writable). Tryk derefter på
"Next &gt;&gt;".
</para>

<para>
Nu kommer en ny ting i WINE-konfigurations processen
frem. Indstillingen af Windows-mappen. Her skal du bare vælge den
mulighed hvor der står (Create a new windows directory:
<filename>/home/anne/.wine/fake_windows</filename>) være. Tryk
derefter på "Next &gt;&gt;"
</para>

<para>
Nu kommer der et nyt vindue op hvori du kan konfigurere WINE. Nu vil
jeg systematisk gennemgå hver punkt i den venstre side af
konfigurationsvinduet:
</para>

<sect4 id="wine-basic">
<title>Basic</title>

<itemizedlist mark="bullet">
<listitem>
 <para>
<emphasis>Look & Feel</emphasis>
Vælg hvilket styresystem dine Windows programmer skal have udseende
efter. Du kan vælge mellem Windows 3.1, Windows 95 eller Windows 98.
 </para>
</listitem>

<listitem> 
 <para>
  <emphasis>Window Mode</emphasis>
 Her kan du vælge hvordan programmerne der bliver kørt med WINE skal
optræde på dit skrivebord. Vælg mellem tre indstillinger.
 </para>

<para>
<emphasis>Managed:</emphasis> De Windows applikationer som bliver
kørt, bliver mere integrerede i din X opsætning, og kommer derfor til
at se flottere og mere "Linux-agtige" ud. Nogle gange kan
Windows-programmerne og X dog ikke helt finde ud af at køre rigtigt
sammen, så nogle gange skaber det problemer, at køre med
"managed". Problemer som man vil kunne undgå hvis man vælger en af de
to andre indstillinger.  
</para>

<para>
<emphasis>Unmanaged:</emphasis> Nu bliver programmet ikke integreret i
din X opsætning og ser derfor ud som det ville have gjort under
Windows. Her er der ingen problemer med at X kan få programmet til
ikke at køre rigtigt og derfor vil programmer der ikke kan køre som
managed, i nogle tilfælde godt køre som unmanaged. Hvis man vælger
denne indstilling kan man godt køre programmerne som managed uden at
skulle konfigurere WINE igen (læs senere i denne
instruktionsvejledning). Dette virker ikke den modsatte vej. Altså
hvis man har valgt managed kan man ikke køre programmet som unmanaged
uden at skulle konfigurere WINE igen.
</para>

<para>
<emphasis>Desktop:</emphasis> Her får du mulighed for at åbne dine Windows programmer i
noget som ligner et Windows skrivebord samt den opløsning
"skrivebordet" skal være. Dette skulle efter sigende være det
uddseende som flest programmer virker med. Selve "skrivebordet" ser
"managed" ud mens programmet der kører i skrivebordet ser "unmanaged"
ud. Hver gang du åbner en ny applikation så åbnes der også et nyt
skrivebord. Nogle mennesker foretrækker denne indstilling. Jeg synes
også at den er nyttig til tider, men dog synes jeg at programmerne
generelt kommer til at fylde for meget hvis man ser dem i
"desktop-mode" og normalt virker programmer fint i både unmanaged og
managed.
</para>


<para>
På <xref linkend="gozdesktop-fig">, <xref linkend="gozmanaged-fig"> og
<xref linkend="gozunmanaged-fig">,  kan du se tre forskellige screenshots
hvor jeg har prøvet at køre Windows-programmet Go!Zilla via WINE under
managed, unmanaged og desktop 640x480.
</para>

<para>
Normalt kan man bare stoppe her ved at trykke på "Finish"-knappen. Så
burde det være klart til brug. Hvis noget går galt, du er nørdet af
natur eller du bare gerne vil rode lidt mere med WINE, så læs videre.
</para>
</listitem>
</itemizedlist>

<FIGURE ID="gozdesktop-fig" FLOAT="1">
<TITLE>Gozilla desktop</TITLE>
<GRAPHIC FILEREF="gozdesktop.&magic;"  SCALE="60"></GRAPHIC>
</FIGURE>

<FIGURE ID="gozmanaged-fig" FLOAT="1">
<TITLE>Gozilla managed</TITLE>
<GRAPHIC FILEREF="gozmanaged.&magic;"  SCALE="60"></GRAPHIC>
</FIGURE>

<FIGURE ID="gozunmanaged-fig" FLOAT="1">
<TITLE>Gozilla unmanaged</TITLE>
<GRAPHIC FILEREF="gozunmanaged.&magic;"  SCALE="60"></GRAPHIC>
</FIGURE>
</sect4>

<sect4 id="wine-advanced">
<title>Advanced</title>

<itemizedlist mark="bullet">
<listitem>
 <para>
<emphasis>Drives</emphasis>  Her kan du indstille dine
drev. F.eks. hvor dit CD-ROM-drev ligger og hvor dit C-drev ligger
osv. F.eks. betyder denne linie: "A Floppy /mnt/floppy /dev/fd0" . A =
Windows-drevbogtav. Floppy = type hardware. /mnt/floppy = hvor på
Linux drevet befinder sig. <filename>/dev/fd0</filename> = hardware
stien. Hvis du er i tvivl om dine hardwarestier er indstillet korrekt
kan du åbne en konsol og skrive <command>emacs /etc/fstab</command>
(du skal dog passe godt på ikke at ændre noget i denne fil da den er
ret vigtig). F.eks. var D-drevet på min computer
(<filename>/mnt/cdrom</filename>) automatisk indstillet til at have
hardware adressen <filename>/dev/hdd</filename> og jeg skulle så selv
ændre det til <filename></filename>/dev/cdrom. Dette gøres ved at
trykke på linien for det stk. hardware man ønsker og derefter trykke
på knappen "Edit". I det vindue som kommer frem kan man så indstille
det stk. hardware man har valgt.
 </para>

<FIGURE ID="winedrives-fig" FLOAT="1">
<TITLE>WINE drev</TITLE>
<GRAPHIC FILEREF="../images/winedrives.&magic;"  SCALE="60"></GRAPHIC>
</FIGURE>

</listitem>



<listitem> 
 <para>
<emphasis>Paths</emphasis>
Her kan du bare se hvor dine falske Windows-mapper (altså de mapper
som WINE selv laver) bliver placeret.
 </para>
</listitem>


<listitem> 
<para>
<emphasis>Look & Feel</emphasis>
Her kan du vælge mellem fire indstillinger:
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
<emphasis>Use DGA</emphasis>
Denne indstilling sørger for at det såkaldte DirectDraw arbejder bedre
sammen med X og det kan derfor overtage hele skærmen og køre
programmerne i "full screen" ved maximum hastighed. Dog har brugen af
DGA også en mindre heldig side. Hvis WINE går ned (crasher) mens det
bruger DGA så kan det ske at computeren fuldstændig standser og det
bliver nødvendigt at skulle genstarte computeren for at få kontrol
over den igen.
 </para>
</listitem>

<listitem> 
 <para>
<emphasis>Use X shared memory</emphasis>
Denne indstilling tillader programmer, som bliver kørt i WINE, at køre
hurtigere end de normalt ville gøre i X. Dog langt fra så hurtigt som
hvis de brugte DGA.
 </para>
</listitem>

<listitem> 
 <para>
<emphasis>DX grab</emphasis>
Hvis man ikke bruger DGA så sørger denne indstilling for at
musemarkøren holder sig inde i WINE-vinduet. Hvis WINE chrasher mens
man kører med DX grab så standser computeren ligesom med DGA (her kan
man dog benytte keyboardet og derved få lukket X).
 </para>
</listitem>

<listitem> 
 <para>
<emphasis>Double-buffered desktop.</emphasis> Dette har kun betydning
hvis du bruger komandoen <command>wine --desktop</command> til at
starte dine WINE-programmer i stedet for bare at skrive wine.    Det
bestemmer om der skal bruges det såkaldte "double-buffered visual."
Det er noget som de fleste OpenGL-spil skal bruge for at køre
rigtigt. Codeweavers WINE understøtter dog ikke OpenGL, så hvis der
skal spilles 3D-spil via WINE (f.eks. Half-Life) så skal du prøve at
se på den "rigtige" WINE side.
</para>

<para>
Jeg har kun valgt at have Use DGA og Use X shared memory slået til,
men det er lidt en smagssag. 
</para>
</listitem>

</itemizedlist>
</listitem>


<listitem> 
 <para>
<emphasis>DLLs</emphasis>
.dll filer er Windows' systemfiler. I denne menu kan du vælge
hvordan WINE skal forholde sig til de systemfiler som det
understøtter. Der er tre muligheder for at vise WINE hvilke
systemfiler der skal bruges fra de forskellige steder. Der er builtin,
native og so. Hvis du ikke har Windows så bør alle filerne stå som
"builtin" bortset fra nogle specielle filer. Bl.a dem der hedder noget
med "glide", de bør stå som "so". Codeweavers WINE bør dog selv
indstille dette korrekt. "Builtin" fortæller WINE at systemfilerne
skal findes blandt WINEs "kunstige" .dll filer. Altså de systemfiler
som følger med WINE. "So"-filer bruges til programmer som har de samme
API calls under både Windows og Linux (som f.eks. Glide). Ved at vælge
at filerne skal findes "native" kan man (hvis man har en version af
Windows installeret) få WINE til at bruge Windows' systemfiler. På
computeren hvor denne HOW-TO er lavet har jeg dog ikke installeret
Windows og beskrivelsen af native-funktionen har jeg derfor valgt at
udelade.
 </para>
</listitem>

<listitem> 
 <para>
<emphasis>Ports</emphasis>
Her kan du indstille hardwareadresserne til dine porte bag på
computeren. Disse porte burde være rigtigt indstillede og du bør
derfor kun rette i dem hvis det ikke virker på din computer.
 </para>
</listitem>

<listitem> 
 <para>
<emphasis>Registry</emphasis>
Her bør alle valgmulighederne bare være slåede til. De handler om
hvor WINE kan hente og skrive sine informationer fra og til.
 </para>
</listitem>

<listitem> 
 <para>
<emphasis>Finish</emphasis>
Her kan du se hvordan din WINE-konfigurationsfil kommer til at se ud.
Så er der bare tilbage at trykke på "Finish"-knappen nede i højre hjørne.
 </para>
</listitem>


</itemizedlist>

<para>
I denne vejledning valgte vi at bruge en personlig konfigurationsfil
og personlig WINE-mappe. Derfor skal du konfigurere WINE for hver
bruger inden du du kan benytte WINE, med den nye bruger.
</para>

<para>
Når man skal åbne programmer med WINE kan man normalt bare skrive wine
eksempel.exe i en xterm eller bare dobbeltklikke på ikonet i din
filmanager. Dette er dog ikke det eneste mulighed. Man kan ændre WINEs
indstillinger for hvert enkelt program bare ved hjælp af simple
kommandoer. Nederunder vil jeg fortælle om nogle af de mest
nødvendige.
</para>


<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>wine --desktop YYYxZZZ eksempel.exe</userinput>
</screen>

<para>
Bemærk at der skal to minus-tegn foran "desktop".
</para>

<para>
Her er kan du fortælle WINE at det skal åbne Windows-programmet i sit
eget lille skrivebord. I stedet for YYYxZZZ skal du indsætte pixlerne
for den størelse du ønsker vinduet skal fylde. Det er dog ikke bare
hvilke som helst tal, men skal være de normale
skrivebordsstørelser. F.eks. <command>wine --desktop 800x600
eksempel.exe</command> Dette er især smart hvis du vil køre programmer
der normalt fylder hele skærmen. Du kan altså få et fuld-skærms
program til at køre i et vindue. F.eks. hvis normalt bruger en
skærmopløsning på 1024x768 pixels.
</para>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>wine --managed eksempel.exe</userinput>
</screen>

<para>
Her er kan du fortælle WINE at det skal integrere programmet bedre i
din window-manager. Dette gælder selvfølgelig kun hvis du har valgt at
WINE normalt skal åbne programmer "unmanaged."
</para>

<para>
Hvis du vil vide mere om hvordan man starter, installerer og kører
programmer via WINE, så læs videre i næste afsnit.
</para>
</sect4>
</sect3>
</sect2>

<sect2 id="installere-programmer-under-wine">
<title>Installere programmer under WINE</title>
<para>
For at installere et program via WINE er der ikke mange ting der skal
gøres (hvis det virker). Egentlig bør du bare kunne skrive <command>wine
et-eller-andet-program</command> for at installere og køre det, men der er dog
alligvel nogle små ting der skal/kan gøres udover det.
</para>

<para> 
Her vil jeg vise hvordan man installerer spillet Caesar III via
WINE. Det sker igennem en 13 skridts installationsprocedure som
egentlig kun har betydning hvis du ejer spillet Caesar 3. Jeg har dog
taget det med alligvel så folk se hvor meget WINE faktisk ligner det
rigtige Windows. 
</para>

<orderedlist>
<listitem>
 <para>
Det første du skal gøre er at lægge din Caesar 3-CD-ROM i CD-ROM-drevet.
 </para>
</listitem>

<listitem>
 <para>
 Så skal du åbne en Xterm.
 </para>
</listitem>

<listitem>
 <para>
 Monter dit cdrom-drev ved at skrive <command>mount
 /mnt/cdrom</command> (dette er lavet på en Linux Mandrake-maskine så
 hvis du bruger en anden distribution skal du lige tage højde for at
 dit cdrom-drev måske ligger i en anden mappe, f.eks. på SuSE).
 </para>
</listitem>

<listitem>
 <para>
 Gå ind i cdrom'en ved at skrive <command>cd /mnt/cdrom</command> og
 skriv så <command>wine SETUP.EXE</command>
 </para>
</listitem>

<listitem>
 <para>
 Nu starter programmet med at vise et stort Sierra-logo og et lille
vindue der indikerer hvor langt programmet er nået med at indlæse
installations-proceduren.
 </para>
</listitem>

<listitem>
 <para>
 Herefter bliver hele skærmen sort, pånær en tekst i det øvre venstre
 hjørne hvor der med hvide bogstaver står Caesar 3. Så kommer der et
 nyt vindue frem. Det hedder "Welcome" og der står bare lidt
 tekst. Tryk på knappen "Next>".
 </para>
</listitem>

<listitem>
 <para>
 Nu kommer der et vindue frem som hedder "Setup Type". Her kan du
vælge hvor mange af filerne som skal ligge på computeren og hvor mange
den skal hente fra cdrom'en. Du kan vælge mellem tre forskellige
muligheder:
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
Full Install - Dette kræver 542 MB fri diskplads.
 </para>
</listitem>
<listitem>
 <para>
Minimum Install - Dette kræver 150 MB fri diskplads.
 </para>
</listitem>
<listitem> 
 <para>
Standard Install - Dette kræver 330 MB fri diskplads.
 </para>
</listitem>
</itemizedlist>

<para>
Jeg synes at det er rarest med "Full Install", men der er jo lidt en
smagssag. Vælg den type du gerne vil have og tryk så på knappen
"Next>".
</para>
</listitem>

<listitem>
 <para>
 Så kommer der et vindue der hedder "Choose Destination". Der er
lidt text og nedenunder det er der en "kasse" hvori der står hvor
Caesar3 vil blive installeret. Her plejer der at stå
<filename>C:\SIERRA\Caesar3</filename>.
</para>

<para>
Hvis du hellere vil installere det i en anden folder så tryk på
knappen "Browse..." og vælg der hvor du gerne vil have det placeret
istedet. Til sidst trykker du bare på knappen "Next >".
 </para>
</listitem>

<listitem>
 <para>
Så går installationen igang og du kan se nogle vinduer som viser
hvor langt installationen er nået. Bagved dem er der flotte
3D-billeder fra det gamle Rom og hvis du tænder for din højtalere kan
du høre noget romer-musik.
 </para>
</listitem>

<listitem>
 <para>
Når filerne er installerede bliver skærmen igen sort med Caesar
3-teksten i venstre hjørne. Så kommer der et vindue der hedder
"Install". Her står lidt tekst og du skal bare trykke på knappen "Ok".
 </para>
</listitem>

<listitem>
 <para>
Der kommer så højst sandsynligt et vindue som også hedder
"Install". Har står der at du ikke har DirectX installeret og der
bliver spurgt om du vil installere det. Her skal du bare trykke på
knappen "Nej".
 </para>
</listitem>

<listitem>
 <para>
Det næste vindue hedder "Display Read Me". Her kan du vælge at
læse readme-filen for Caesar3. Jeg plejer dog bare at trykke på
knappen "Nej".
 </para>
</listitem>

<listitem>
 <para>
 Det sidste vindue hedder "Setup Complete". Der står nogle få
 linier tekst og du skal bare trykke på knappen "Finish".   
 </para>
</listitem>
</orderedlist>


<para>
Så er programmet installeret og nu skal vi se om det virker. Åbn en
xterm og skriv mount /mnt/cdrom (hvis du nu har haft din computer
slukket eller brugt andre cdrom'er i mellemtiden (dette er lavet på
en Linux Mandrake-maskine så hvis du bruger en anden distribution skal
du lige tage højde for at dit cdrom-drev måske ligger i en anden
mappe, f.eks. på SuSE)). Derefter cd
/home/anne/.wine/fake_windows/SIERRA/Caesar3 Så langt så godt. Nu
er det lidt forskelligt hvordan du kan starte programmet alt efter
hvilken skærmstørelse du har. Som du læste tidligere kan du gøre
forskellige ting. Hvis du har en skærmopløsning på 640x480 eller
800x600 pixels, så skal du bare starte programmet ved at skrive wine
c3.exe Nu burde Caesar 3 starte i full screen. Hvis du tilgengæld har
en skærmopløsning større end det skal du skrive enten wine --desktop 
640x480 c3.exe eller wine --desktop 800x600 c3.exe alt efter hvor stor
en skærmstørelse du gerne vil have det i. Så starter Caesar 3 i et
WINE-skrivebord som har størrelse efter de to tal du skrev før
(f.eks. 640x480). Hvis du er i tvivl om hvad du skal vælge så kan du
jo bare prøve begge to (dog ikke på samme tid :-).
</para>

<para>
Her kunne denne vejledning vel godt ende, men det gør den ikke. For
hvem gider egentlig skrive
</para>

<screen>
 mount /mnt/cdrom
 cd /home/anne/.wine/fake_windows/SIERRA/Caesar3
 wine --desktop 800x600 c3.exe
</screen>

<para>
hver gang hvis der er en nemmere metode. Faktisk kan du gøre sådan at
Caesar 3 starter præcis som du vil have det bare ved at skrive
<command>caesar3</command> i en xterm. Det er dog ikke noget som WINE
på forhånd har gjort, næ det er noget vi selv skal til. Det vi skal
lave hedder et shell-script.
</para>

<para>
Lad os sige at vi står i vores hjemmemappe
<filename>/home/anne</filename>. Det første du skal gøre er at åbne
din foretrukne editor og lave en fil der hedder
<filename>caesar3</filename>. Hvis du er i tvivl så åbn en xterm (og
så sørg for at du står i din hjemmemappe) og skriv så <command>emacs
caesar3</command>. Så kommer editoren Emacs frem og har både lavet og
åbnet filen caesar3. Nu skal du så indtaste følgende i filen: 
</para>

<screen>
#!/bin/sh
echo "Starter Caesar III"
mount /mnt/cdrom
cd /home/anne/.wine/fake_windows/SIERRA/Caesar3
wine --desktop 800x600 c3.exe
</screen>

<para>
Forklaringen på hvad filen gør kommer her:
</para>

<para>
<command>#!/bin/sh</command> - Her starter dit shell-script
</para>

<para>
<command>echo "Starter Caesar III"</command> - Denne linie skriver
Starter Caesar III i xtermen når den starter. Den er egentlig
ligegyldig men det giver en flot "effekt" og så ved du også at
shell-scriptet faktisk er igang.
</para>

<para>
<command>mount /mnt/cdrom</command> - Her fortæller du dit cdrom-drev
at Caesar 3 CD'en er i dit cdrom-drev (dette er lavet på en Linux
Mandrake-maskine så hvis du bruger en anden distribution skal du lige
tage højde for at dit cdrom-drev måske ligger i en anden mappe,
f.eks. på SuSE).
</para>

<para>
<command>cd /home/anne/.wine/fake_windows/SIERRA/Caesar3</command>
- Dette fortæller Linux at den skal gå ind i mappen
<filename>/home/anne/.wine/fake_windows/SIERRA/Caesar3</filename>
</para>

<para>
Til sidst skal du indsætte den kode du bruger til at starte Caesar
3. Hvis du bare plejer at skrive wine c3.exe så skriv det. Jeg bruger
linien <command>wine --desktop 800x600 c3.exe</command>
</para>

<para>
Nu skal du bare gemme filen og lukke editoren. Hvis du bruger Emacs
kan du gøre det hele via keyboardet. Du trykker (og holder den nede)
først på "Ctrl"-tasten og derefter en gang på x (eller skrevet kort
Ctrl-x). Tryk så Ctrl-s Giv så slip fra "Ctrl"-tasten. Nu er
dokumentet gemt. Tryk så først Ctrl-x og derefter Ctrl-c Så har du
lukket det.
</para>

<para>
Nu skal du have aktiveret dit shell-script, for Linux kan ikke bare
starte en tekstfil. Dette gør du ved at åbne en xterm og gå ind i
samme mappe som du har lavet caesar3-filen i (formodentlig i dit
hjemmekatalog). Her skriver du så <command>chmod +x caesar3</command>
Så er den gjort klar. Prøv nu at skrive <command>./caesar3</command> i
en xterm og se om Caesar 3 starter (og om det står på skærmen). Hvis
det gør det så virker scriptet. Hvis det ikke virker (og det virkede
da du startede Caesar 3 "manuelt" så bør du lige kigge din kode og
instruktionerne her igennem igen og lige tjekke at alt er stavet
rigtigt. Husk at forskellen på store og små bogstaver har en
betydning!)
</para>

<para>
Nu skal det så gøres endnu nemmere. I en xterm skriver du følgende
kommandoer:
</para>

<para>
<command>cd /home/anne</command> - Dette sætter dig ind i Annes
hjemmesmappe
</para>

<para>
<command>su</command> (skriv derefter dit root-kodeord) - Dette giver
dig root-rettigheder
</para>

<para>
<command>cp caesar3 /bin</command> - Dette kopierer filen
<filename>caesar3</filename> til mappen <filename>bin</filename>
</para>

<para> 
<command>cd /bin</command> - Dette sætter dig ind i mappen
<filename>/bin</filename>.  Det her her at mange af Linux' kommandoer
ligger. Når filen bliver placeret her kan den eksekveres uden at
fortælle filens sti. Altså kan man skrive <command>caesar3</command> 
i stedet for at
skulle skrive <command>/home/anne/caesar3</command>
</para>

<para>
<command>chmod -R 777 caesar3</command> - Dette
giver alle brugere fuld adgang til filen exit - Så vender du tilbage
til din normale bruger
</para>

<para>
Nu kan du så prøve at gå ind i en vilkårlig mappe og så skrive caesar3
Så bør Caesar 3 starte, helt automatisk. 
</para>
</sect2>
</sect1>

<sect1 id="VICE">
 <title>Commodore-emulering</title>

 <indexterm><primary>C64</primary></indexterm>
 <indexterm><primary>emulator</primary>
            <secondary>Commodore 64</secondary></indexterm>

 <para>
  Hvis du som denne bogs forfattere er vild med din gamle Commodore 64, er
  VICE noget for dig. VICE er en forkortelse for "Versatile Commodore 8-bit
  Emulator" (eller måske VIC Emulator). VICE kan emulere Commodore 64,
  Commodore 128, VIC 20 og Commodore PET. Ud over udgaver til Linux (Unix)
  findes VICE til MS-DOS og Windows. VICE er i sandhed en alsidig emulator.
 </para>

<para>
VICE følger ikke med en standard Red Hat distribution, men du finder
den let på et ftp-site, f.eks. <ulink url="ftp://sunsite.auc.dk">ftp://sunsite.auc.dk</ulink> under Red
Hat-contrib. Installationen kan drille lidt, idet VICE kræver
<filename>libstdc++</filename> version 2.9. Dette bibliotek er
installeret ved en standard installation, men navnet kan være
forkert. Nedenfor ser du, hvordan du kan installere VICE - du bør
tjekke, hvilket navn <filename>libstdc++</filename> har i
<filename>/usr/lib</filename>.
</para>

<screen>
<prompt>[anne@linus ~]$</prompt> <userinput>su -</userinput>
Password: 
<prompt>[root@linus root]#</prompt> <userinput>cd /usr/lib</userinput>
<prompt>[root@linus root]#</prompt> <userinput>ln -s libstdc++-2-libc6.1-1-2.9.0.so libstdc++.so.2.9</userinput>
<prompt>[root@linus root]#</prompt> <userinput>rpm -ivh --nodeps vice-1.0-1.i386.rpm</userinput>
</screen>

<para>
Efter installationen er du klar til at bruge VICE. Afhængigt af, hvilken
Commodore-computer, du ønsker at emulere, skal du benytte et af
følgende programmer: <command>x64</command> (Commodore 64),
<command>x128</command> (Commodore 128), <command>xvic</command> (VIC
20) eller <command>xpet</command> (PET).
</para>

<para>
VICE kan emulere lyd og grafik samt ydre enheder, dvs. båndstationer,
diskettestationer (Commodore 1571) og joystick. Din emulator kører i
et selvstændigt vindue under X. Højre og venstre museknap giver dig
menuer til at styre VICE. Bånd og disketter emuleres ved, at du har
indholdet liggende i en fil på din harddisk. Trykker du på venstre
museknap, kan du "attach a disk image" og "attach a tape image",
dvs. du kan vælge, hvilken fil der er dit bånd eller din
diskette. Bånd og disketter gemmes i særlige formater.
</para>

<para>
Det er let at finde gamle spil til f.eks. Commodore 64 rundt om på
Internettet. Tjek f.eks. <ulink
url="http://www.c64.com">http://www.c64.com</ulink> som har ca. 2500
liggende.
</para>

<FIGURE ID="vice-fig" FLOAT="1">
<TITLE>Spillet Soccer</TITLE>
<GRAPHIC FILEREF="vice.&magic;"  SCALE="40"></GRAPHIC>
</FIGURE>
</sect1>

<sect1 id="vnc">
<title>VNC til fjernstyring af dine maskiner</title>

<!-- Dette afsnit er skrevet af Bent Pedersen bentriloquist@my-deja.com -->
<para>
VNC står for Virtual Network Computing. Kender du
programmer som PC Anywhere eller NetOp, som begge kører på
Windows-platformen, så har du en god idé om hvad VNC er: et program
til fjernstyring af en anden PC med grafisk brugerflade. 
Dog kører VNC over TCP/IP, og ikke
andet. VNC består af en server-del, som kører på den maskine du ønsker
at fjernstyre, samt en klient-del, som kører på den maskine du sidder
foran.
</para>

<sect2 id="vnc-ide"> <!-- Af Erling Sjørlund es@es-data.dk -->
<title>Integration af serveren på arbejdspladsen med VNC</title>
<para>
Hvis du har et lille system med en Linuxserver og en eller flere
arbejdspladser med Windows, kan du med VNC få en let og effektiv adgang til
at arbejde med serveren direkte på din arbejdsplads.
Installer først vncserver på din Linux-server. Log ind på serveren på dit
almindelige brugernavn (ikke root), og start vncserveren, fx. med :1 som
nummer. Log ind under et andet brugernavn og start vncserver igen, her med
:2 som nummer.
</para>

<para>
Hvert nummer har sin egen opsætning, så du kan evt. starte en vncserver til
hvert familiemedlem, efter at du har logget ind på serveren som vedkommende.
Start derefter vncviewer på din arbejdsplads i et vindue, og log ind med det
password du oplyste første gang vncserver blev startet (på Linux-serveren
under det :nummer du bruger). Det letteste er nok at bruge dens IP-nummer,
altså fx. 192.168.1.1:1, hvor det sidste :1 skal svare til det nummer du gav
på serveren.
</para>

<para>
Nu har du et miljø, hvor du uden videre kan veksle mellem vinduet med
serverens X-variant og Windows-brugerfladen. Du kan direkte klippe-klistre
tekst mellem Linux- og Windowsprogrammer, og i det hele taget gøre på
serveren hvad din adgang tillader dig.
Hvis du ikke har behov for at skifte bånd, CD'er, disketter eller lignende
på din server, kan du nu parkere din server så langt væk som muligt, (fx. i
kælderen, så den kan bidrage til opvarmningen af huset).
</para>

<para>
Du får nu disse fordele:
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
Serveren skal hverken have skærm, mus eller tastatur for at kunne anvendes
fuldt ud.
 </para>
</listitem>
<listitem> 
 <para>
Du kan (mere eller mindre frivilligt) lukke Windows ned på din
arbejdsplads. Næste gang du åbner Windows+vncviewer, vil den kun vise en blå
skærm, hvis det er den farve, du har valgt frivilligt. (Det forudsættes her,
at du ikke sådan går rundt og lukker din server i tide og utide).
 </para>
</listitem>
<listitem> 
 <para>
Du kan arbejde sammen med din mand/kone i den samme skærm uden at skulle
slås om tastatur, mus og overblik. I login-dialogen (Billede ind
heromkring?) klikker du blot på knappen [Options], og afkrydser "Request
shared session" nederst i venstre hjørne. Det, den ene skriver, bliver
blandet ind i det, den anden er i gang med. Skulle I blive trætte af det,
(og det kan ske selv i de bedste forhold), kan man naturligvis også arbejde
samtidigt på hver sin maskine, uden at blande sig sammen. Det kræver blot,
at du starter vncserver flere gange på Linux-serveren med hvert sit :nummer,
og logger ind fra arbejdspladserne med forskellige numre.
 </para>
</listitem>
<listitem> 
 <para>
Har du børn med egen maskine i familien (det har man hørt om), kan du
installere vncserver på deres maskiner, og kigge dem over skulderen, helt
uden at de behøver at opdage det.
På den måde slipper du for at komme alt for tæt på dem, og du ved alt hvad
de gør uden at tale med dem først. Det hele bliver som i de gode gamle dage,
hvor jeg er sikker på, at alle mødre havde et lignende system, der gjorde,
at de næsten altid vidste, hvad deres børn havde gang i.
 </para>
</listitem>
</itemizedlist>

</sect2>



<sect2 id="vnc-installation">
<title>Installation af VNC</title>

<para>
For eksemplets skyld antages, at du ønsker at fjernstyre din
Linux-maskine fra en Windows-maskine. Du skal altså hente en
Linux-server og en Windows-klient.  Man kan også fjernbetjene en
Windows-maskine - selv mens andre sidder ved maskinen. Yderst smart
til support.
</para>

<para>
Først skal VNC-serveren hentes. Det kan gøres fra
<ulink url="http://www.uk.research.att.com/vnc">http://www.uk.research.att.com/vnc</ulink>, som er det sted hvor udviklerne
lægger kildekoden. Desværre kan man derfra ikke hente RPM-pakker,
men gå til 
<ulink url="http://www.rpmfind.net">http://www.rpmfind.net</ulink>
og søg efter <EMPHASIS>vnc-server</EMPHASIS>.
Version 3.3.3r2 eller nyere kan findes der.
</para>

<para>
VNC-serveren skal installeres som root:
</para>

<screen>
<prompt>[root@linus root]# </prompt><userinput>rpm -Uvh vnc-server-3.3.3r2-4.i386.rpm</userinput>
</screen>
</sect2>

<sect2 id="vnc-server-start">
<title>Start en server</title>
<para>
vncservers man-side oplyser følgende:
</para>

<screen>
vncserver [:number] [-geometry widthxheight] [-depth depth] 
 [-pixelformat rgbNNNbgrNNN] [-name desktop-name] [Xvnc-options]
</screen>

<para>
Der er altså mange options, men du behøver kun ganske få for at komme igang.
</para>

<para>
Et eksempel på start af VNC-server:
</para>

<screen>
<prompt>[anne@linus ~]$ </prompt><userinput>vncserver :1 geometry 800x600 depth 8</userinput>
</screen>

<para>
Hvilket betyder: lav en ny X-desktop med størrelsen 800x600 pixels og
8 bits pr pixel (=256 farver) og lyt på TCP/IP 5801. 5801? Ja, for VNC
lægger automatisk 5800 til det nummer man angiver, og bruger det som
port-nummer.
</para>

<para>
Du kan bruge en hvilket som helst størrelse du ønsker, også skæve
størrelser som f.eks. 200x500, hvis du ønsker det. Vær opmærksom på,
at jo større desktop du bruger, desto mere skal der sendes på nettet,
og det giver reduceret hastighed. 
En mulig opløsning kunne være 800x600x8bpp til VNC-serveren, selv om
den fysiske desktop kører 1024x800x16bpp. Ved at vælge denne mindre
opløsning giver det 3,5 gange mindre trafik.

Desuden er et baggrundsbillede
også vejen til langsom hastighed, så brug en ensfarvet baggrund i
stedet for dine feriebilleder.
</para>

<para>
Første gang du starter vncserver, skal du angive et password. Dette
password skal du opgive, når du senere forsøger at forbinde dig til
maskinen. Hvis du ønsker at ændre passwordet kan du blot køre
programmet vncpasswd.
</para>

<para>
Når du vil lukke din VNC-server igen foregår det sådan:

</para>

<screen>
<prompt>[anne@linus ~]$ </prompt><userinput>vncserver -kill :1</userinput>
</screen>

</sect2>

<sect2 id="vnc-opsaetning">
<title>Opsætning</title>

<para>
Bruger du fx Gnome som dekstop,
er det en fordel at bruge en anden Window Manager når kobler op til VNC.
Et valg kunne være IceWM der føles en lille smule hurtigere,
og hver lille smule hastighed tæller.
</para>

<para>
Af dokumentationen fremgår det at <command>vncserver</command> bruger
<filename>$HOME/.vnc/xstartup</filename> som startfil. Det er altså
stedet, hvor sådanne ændringer skal laves. 
En eksempel på en ændret xstartup kan se således ud:
</para>

<screen>
#!/bin/sh
xrdb $HOME/.Xdefaults &
exec icewm
</screen>

<para>
Hvis du i stedet ønskede at bruge Gnome, så skulle linien med exec
icewm ændres til <command>exec gnome-session</command> og tilsvarende
anvender KDE <command>exec startkde</command>. Dette kræver
selvfølgelig, at IceWM, Gnome og/eller KDE er installeret i forvejen.
</para>

<para>
Bemærk i øvrigt at standard window manager for VNC er
<command>twm</command>, som vel kun de færreste ønsker at bruge.
</para>
</sect2>

<sect2 id="vnc-klienten">
<title>Klienten</title>
<para>
  Der findes klienter til både Windows og Linux. Da disse er oversat specifikt
  til det relevante system er de mindre processorkrævende. Men den smarteste
  klient er dog den til Java.
</para>

<para> 
  Har du en browser, der kan snakke Java, så gå ind
  på: <filename>http://x.x.x.x:5901</filename>. 
  Her angiver du brugernavn og adgangskode
  hvorefter du i din browser kan fjernstyre maskinen.       
</para>

<FIGURE ID="vnc1-fig" FLOAT="1">
<TITLE>VNC - hvor en Linux-maskine styres fra en Internet Explorer fra Windows</TITLE>
<GRAPHIC FILEREF="vnc1.&magic;"  SCALE="40"></GRAPHIC>
</FIGURE>

<FIGURE ID="vnc2-fig" FLOAT="1">
<TITLE>VNC - hvor en Windows-maskine styres fra en Linux-maskine via Netscape</TITLE>
<GRAPHIC FILEREF="vnc2.&magic;"  SCALE="40"></GRAPHIC>
</FIGURE>

</sect2>

<sect2 id="vnc-pas-paa">
<title>Pas på din sikkerhed</title>

<para>
Bemærk at <command>vncserver</command> giver brugeren af klienten de
samme rettigheder, som den konto der startede den.  Er du logget ind
som "guest" når du starter <command>vncserver</command>, får alle der
logger på via en vnc-klienten "guest" rettigheder.  Af hensyn til
sikkerheden bør du derfor ikke starte den som root, og det er også
klogt at huske nedlukning af vncserver, når den ikke skal bruges.
 </para>

<para>
Bemærk også, at hvis du har startet vncserver direkte i en konsol på
serveren, så bliver den ved at køre, også selv om du forsøgt logout.      
</para>

<para>
VNC er en åbning af et potentielt sikkerhedshul - i hvertfald er
versioner op til og med 3.3.3 ikke sikre, jfr. Weekly Linux Security
Digest 2001/01/22-2001/01/28. I de ældre versioner kan man bryde ind i
trafikken mellem server og klient.
</para>
</sect2>
</sect1>
</chapter>
