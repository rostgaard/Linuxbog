<chapter id="kerne">
<title>Linux kernen</title>

<sect1 id="Hovedkarakteristika">
<title>Hovedkarakteristika ved Linux kernen</title>

<itemizedlist mark="bullet">
<listitem>
 <para>
<emphasis>Multi-tasking</emphasis>
Linux understøtter ægte multi-tasking. Alle processer kører helt
uafhængigt af hinanden. Ingen processer behøver at tage højde for at
sørge for processor-tid til andre processer.
 </para>
</listitem>

<listitem> 
 <para>  
  <emphasis>Multi-user access</emphasis>
Linux tillader et antal brugere at benytte systemet samtidigt.
 </para>
</listitem>

<listitem> 
 <para>
  <emphasis>Demand load executables</emphasis>
Kun de dele af et program, som faktisk er påkrævet for eksekveringen
er load'et ind i hukommelsen. Når en ny proces er skabt ved hjælp af
fork(), afsættes der ikke straks hukommelse, men i stedet bruges
hukommelsen fra "parent" processen af begge processer. Hvis den nye
proces så på et tidspunkt søger adgang til en del af hukommelsen i
"write mode", kopieres denne sektion før den ændres. Dette koncept
kendes som "copy-on-write"; det er med til at øge hastigheden og sænke
hukommelsesforbruget.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Paging</emphasis>
På trods af forsøg på at anvende fysisk hukommelse effektivt, kan det
ske, at den tilstedeværende hukommelse er brugt op. Linux ser så efter
4 kbyte hukommelses-pages, som kan frigives. Pages med deres indhold
lagret på harddisk (f.eks. koden for program filer) frigives. Alle
andre pages kopieres ud på harddisken. Hvis der herefter søges adgang
til en af disse hukommelses-pages, load'es den igen. Denne procedure
kaldes paging. Den adskiller sig fra swapping, som anvendes i ældre
UNIX-systemer, hvor hele hukommelsen for en proces skrives til
harddisken, hvilket er betydeligt mindre effektivt.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Dynamisk cache for harddisken</emphasis>
Brugere af MS-DOS er kendt med behovet for at reservere hukommelse af
en bestemt størrelse til harddisk cache programmer som SMARTDRIVE.
Linux justerer dynamisk størrelsen af cache hukommelse som bruges, for
at tilpasse sig den nuværende hukommelsessituation. Hvis der ikke er
mere hukommelse tilbage på et givent tidspunkt, reduceres størrelsen
af cachen for at frigive hukommelse. Når først hukommelse er frigivet,
øges cache området igen.
 </para>
</listitem>


<listitem> 
 <para>
 <emphasis>Shared libraries</emphasis>  
Libraries er samlinger af rutiner, som er nødvendige for
data-processing for et program. Linux har et antal standard libraries,
der bruges af flere processer ad gangen. Det er derfor fornuftigt at
load'e programkoden for disse libraries ind i hukommelsen én gang for
alle. Dette muliggøres ved hjælp af shared libraries. Da disse kun
loades til programkoden når processen eksekveres, kendes de også som
dynamisk linked libraries (dll).
 </para>
</listitem>

<listitem> 
 <para>
Understøttelse for POSIX 1003.1 standard og delvis System V og BSD
POSIX 1003.1 definerer et minimum interface for et UNIX type
operativsystem. Dette interface er beskrevet i C-funktion
deklarationer. Denne standard understøttes nu af alle nyere og
relativt sofistikerede UNIX-systemer. Linux i dag  understøtter
tilnærmelsesvis POSIX 1003.1. Yderligere system-grænseflader for UNIX
udviklingsliner System V og BSD er også implementeret. 
 </para>
</listitem>


<listitem> 
 <para>
 <emphasis>Forskellige formater for eksekverbare filer</emphasis>
Da det meste software i dag er skrevet til MS-DOS eller MS-Windows, er
det ønskværdigt at kunne køre programmer til disse systemmiljøer under
Linux. Derfor er emulatorer for MS-DOS og MS-Windows under udvikling.
Linux kan også eksekvere programmer fra andre INTEL-baserede
UNIX-systemer, som går under iBCS2 standard. Dette inkluderer f.eks.
mange kommercielle programmer brugt under SCO UNIX. iBCS2 emulering er
endnu ikke del af standard kernen, men den kan download'es fra
Internettet.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Emulering af matematisk co-processorer i kernen</emphasis>
Linux kan emulere den matematiske co-processor i387, hvis den ikke
findes i systemet. Det vil sige, at programmer ikke behøver at checke,
om der er co-processor til stede. Hvis der ikke er, udføres de
relevante kommandoer i exception handle rutiner. Fra programmørens
side er tilstedeværelsen af en co-processor altså transparent.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Understøttelse for nationale keyboards og fonte</emphasis>
Under Linux kan mange nationale keyboards og fonte anvendes.
ISO-standarden definerer Latin1 sættet, som bl.a. også inkluderer
europæiske specialtegn.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Forskellige filsystemer</emphasis>
Linux understøtter forskellige filsystemer. Det mest almindeligt
brugte filsystem er Second Extended (Ext2) File System. Dette
understøtter filnavne op til 255 tegn, og har et antal træk der gør
det mere sikkert end almindelige UNIX filsystemer. Et andet filsystem,
som også er implementeret, er MS-DOS filsystemet FAT. Det betyder, at
man kan få adgang til data i en MS-DOS-partition på samme måde som i
en Linux-partition, men i MS-DOS systemet understøttes ejerskab kun
for hele filsystemet. Desuden understøtter Linux UMSDOS filsystemet,
som også tillader pseudofiler og UNIX access autorisationer inden for
et MS-DOS filsystem. Ved hjælp af ISO 9660 filsystemet kan brugeren få
adgang til data på CD-rom. I netværk kan man få adgang til filsystemet
på andre systemer transparent ved hjælp af NFS (Network File System).
Linux understøtter desuden VFAT systemet, som bruges af Windows 95 til
lange filnavne. Andre filsystemer, der understøttes er OS/2's HPFS
(read only) og System V filesystem. Grunden til at HPFS er read-only
er at dokumentationen for det ikke er tilgængelig. Ingen har turdet
tage ansvaret for at lave en implementering der måske kunne ødelægge
nogens filsystem. Linux kernel 2.0 understøtter ikke NTFS og FAT32,
men det er på vej i kernel 2.2.
 </para>
</listitem>


<listitem> 
 <para>
 <emphasis>TCP/IP, SLIP og PPP understøttelse</emphasis>
Linux kan integreres i lokale UNIX netværk. I princippet kan alle
netværk services som NFS og Remote Login bruges. SLIP og PPP
understøtter brugen af TCP/IP protokollen over serielle linier. Det
betyder at link til Internet via telefonnetværk ved hjælp af modem er
muligt.
 </para>
</listitem>


<listitem> 
 <para>
 <emphasis>BSD sockets</emphasis>
Netværkskommunikation kræver naturligvis midler til
interproces-kommunikation mellem forskellige computere. Interfaces
hertil er i BSD sockets.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>System V IPC</emphasis>
Linux bruger dette til at lave message queues, semaforer og shared
memory. Disse er klassiske varianter til interproces-kommunikation.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Virtuelle konsoller</emphasis>
Linux understøtter virtuelle konsoller. Tastekombinationen &lt;ALT&gt; +
&lt;Function key&gt; bruges til at skifte imellem dem.
 </para>
</listitem>

<listitem> 
 <para>
 <emphasis>Multiprocessing</emphasis>
Fra kernel 2.0 understøtter Linux symmetrisk multiprocessing -
samtidig kørsel af processer på et antal processorer - op til 16
processorer.
 </para>
</listitem>
</itemizedlist>

</sect1>

<sect1 id="Linux-er-ikke">
<title>Linux er ikke</title>
<para>
Linux er ikke et real-time system. Bl.a. virtual memory gør det
umuligt for Linux at overholde kravene til et "hard" real-time system,
men det kan laves mere real-time end det er i dag, bl.a. ved at
arbejde med scheduling'en og optimere interruptene. PTO
</para>

<para>
Linux er ikke en microkernel (minimal kerne med veldefinerede
grænseflader, så ydre dele nemt kan skiftes ud), men er opbygget som
en monolitisk kerne. PTO
</para>

<para>
Linux er ikke et distribueret operativsystem - alting foregår på én
maskine. MOSIX
</para>

<para>
Linux er ikke sikret efter de strengeste sikkerhedsprincipper, men der
er indbygget en vis beskyttelse mod uforvarende at komme til at
ødelægge systemet.
</para>

<para>
Linux kan ikke køre på en '286 eller ældre maskine, da den udnytter
'386's virtual memory faciliteter.
</para>

</sect1>

<sect1 id="proces-management">
<title>Proces management</title>

<para>
UNIX operativsystemer er multi-programming og multi-user systemer. Det
betyder at flere programmer kan kører på én computer samtidig, og
dermed også at flere personer kan bruge én computer som server
samtidig. For brugeren ser det ud som om programmerne kører parallelt
og at flere processer dermed har CPU'en samtidig. Dette fungerer i
praksis ved at hver proces har CPU'en i et bestemt tidsrum, hvorefter
den ryger bag i en kø og næste proces hentes ind (multi-tasking).
</para>

<para>
Linux understøtter, ligesom UNIX, ægte multi-tasking. Alle processer
kører helt uafhængigt af hinanden, så ingen processer behøver at tage
højde for at give processor-tid til andre processer. Hver proces har
et memory-område, som er beskyttet mod ændringer fra andre processer.
</para>

<para>
Linux i kerne version 2.0 eller senere understøtter multi-processing for
op til 16 processorer. Multiprocessing er samtidig kørsel af processer
på flere processorer. PTO
</para>

<para>
Der er gjort forsøg på at understøtte multi-threading. Threads er dele
af en proces, som i multi-threading systemer kan køre parallelt, som
regel i samarbejde om en fælles opgave. Multi-threading er nyttigt
fordi 2 threads har mere til fælles end 2 tilfældige processer, så det
tager ikke så langt tid at skifte mellem 2 threads som imellem 2
processer. Der er gjort forsøg på at implementere en slags threads i
Linux med systemkaldet clone. Dette er dog stadig på et niveau, hvor
det kan betragtes som et udokumenteret systemkald. Man kan således
endnu ikke sige, at Linux understøtter multi-threading, men måske
kommer det til det.
</para>

<sect2 id="Processtruktur">
<title>Processtruktur</title>
  
<para>
Det vigtigste og mest specielle ved et multi-tasking system er
processerne og processtrukturen. En proces er et program, som er under
udførelse.
</para>

<para>
x86 arkitekturen understøtter 4 privelege modes (eller levels), hvor
mode 0 er den mest privilegerede og 3 den mindst privilegerede. Et
kørende program vil altid være i en af disse modes.
</para>

<para>
Linux bruger kun 2 modes, nemlig kernel mode og user mode. Ved at
skelne mellem user mode og kernel mode kan man forhindre, at brugeren
har direkte adgang til de forskellige I/O devices.
</para>

<para>
Der er kun adgang til disse fra kernel mode, og alle brugerprogrammer
kører i user mode. Brugerprogrammer har derved kun adgang til I/O
devices igennem et på forhånd specificeret systemkald, som resulterer
i et skift fra user mode til kernel-system mode. Derved slipper
programmøren af brugerprogrammer for at bekymre sig om detaljerne
omkring f.eks. I/O. Hardwarens kompleksitet skjules derved for
brugeren.
</para>

<para>
Et brugerprogram kan således bruge operativsystemet til at få udført
forskellige instruktioner, ved at lave et systemkald. Et
brugerprogram, der kører under Linux, vil derfor se Linux-kernen som
en udbyder af servicefunktioner.
</para>

<para>
Når en proces kører i system mode kan den være i en af følgende
tilstande:
</para>

<itemizedlist mark="bullet">
<listitem>
 <para>
  <emphasis>Running</emphasis>
Running illustrerer et kørende program i user mode. Det
meste af tiden kører et program i user mode. En gang imellem er det
dog nødvendigt at gå i kernel mode. Dette kan kun ske ved et interrupt
eller et systemkald.
 </para>
</listitem>
<listitem> 
 <para>
 <emphasis>Interrupt-rutine</emphasis>
Interrupt-rutinen bliver aktiv når der kommer et hardware signal,
f.eks. nye input fra keyboard.
 </para>
</listitem>
<listitem> 
 <para>
  <emphasis>Systemkald</emphasis> 
Systemkald aktiveres af software interrupts. Et
systemkald kan suspendere en proces, så den skal vente på en hændelse.
 </para>
</listitem>
<listitem> 
 <para>
  <emphasis>Waiting</emphasis>
Processen venter på en ekstern hændelse og processen vil ikke
forsætte, før denne hændelse indtræffer.
 </para>
</listitem>
<listitem> 
 <para>
 <emphasis>Retur fra systemkald</emphasis>
Denne tilstand opnås efter hvert systemkald og efter nogle interrupts.
Herfra kan scheduleren skifte processen til Ready og aktivere en anden
proces.
 </para>
</listitem>
<listitem> 
 <para>
 <emphasis>Ready</emphasis>
Processen konkurrerer om at komme til processoren, som er optaget af
en anden proces.
 </para>
</listitem>
</itemizedlist>

</sect2>
  
<sect2 id="Procesrelationer">
<title>Procesrelationer</title>

<para>
Proces-hierarkiet i Linux er et parent-child hierarki. En ny proces
kan kun skabes med systemkaldet <command>fork()</command>. Den nye
proces bliver child-proces til den proces, der udførte
<command>fork()</command>.  
</para>

<para>
Den nye proces bliver oprettet ved at lave en næsten identisk kopi af
den proces der kaldte <command>fork()</command>. Ofte er det første,
en ny proces gør, at udføre et execve kald, som overskriver den
nedarvede kode, stak, registre mv., så den ikke længere er en kopi af
parentprocessen, men en ny proces.
</para>

<para>
Det kan være meget ressourcekrævende at oprette en ny proces, da der
kan være mange data fra parent processen, som skal kopieres. Derfor
bruges der i Linux "copy-on-write" teknikken. Tanken bag denne teknik
er, at et antal af processer kan have adgang til den samme memory, så
længe der ikke er nogle af processerne der laver ændringer i data.
Således bliver de relevante pages af memory ikke kopierede ved
systemkaldet <command>fork()</command>, men den fælles memory bliver
write-protected.  Hvis en af processerne forsøger at skrive til memory
bliver processen interrupted, og kernen laver en kopi af den relevante
page. Herefter kan der tildeles en kopi til hver proces. Den store
fordel ved denne metode er, at data kun bliver kopieret hvis det er
nødvendigt.
</para>
</sect2>

<sect2 id="Proces-ID">
<title>Proces ID</title>

<para>
Alle processer har deres eget ID nummer (pid) og er i en gruppe og en
session. I Linux kan en proces være tilknyttet flere grupper.
</para>

<para>
Når en ny proces bliver genereret får den et nyt pid nummer, og
<command>fork()</command> returnerer 0 til child processen og child
processens pid til parent processen. Derved kan de to processer se,
hvilken proces der er child proces og hvilken der er parent proces.
</para>

<para>
For at kunne bestemme hvor en proces har adgang, har hver proces et
user ID (uid) og et gruppe ID (gid). Disse ID numre har child
processerne arvet efter deres parent processer. Når en adgangskontrol
skal foretages er det dog den effektive user ID (euid) og gruppe ID
(egid) der bliver brugt. Generelt er uid = euid og gid = egid,
undtagen for set-UID programmer. I disse programmer bliver euid og
egid sat til user ID og gruppe ID for ejeren af den eksekver-bare fil.
På denne måde er det muligt for superuseren at give almindelige
brugere adgang til programmer, der bruger superuser power, på en
kontrolleret måde. Et set-UID program er et program hvor
set-UID-bitten er sat. Af sikkerhedsårsager understøtter Linux kun
set-UID på binære filer, ikke på shell scripts.
</para>
</sect2>
</sect1>

<sect1 id="kerne-2-4">
<title>Kerne 2.4</title>
<para>
Den seneste generation af Linuxkernen er 2.4, som udkom i starten af
januar 2000. Linus Torvalds annoncerede diskret at nu er kerne 2.4.0
færdig.
</para>

<para>
Hvad er det så kerne 2.4 har opnået i forhold til de meget anvendte
kerner fra 2.2-serien? Svaret er - mange ting.
</para>
</sect1>
</chapter>
