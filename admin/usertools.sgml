<!-- $Id$ -->
<chapter id="sysadm">
<title>Systemadministration</title>

<para>
I dette kapitel ser vi nærmere på nogle af de værktøjer og opgaver som
systemadministratoren kommer ud for.
</para>


<sect1 id="glemt-passwd">
<title>Har du glemt din adgangskode?</title>

<indexterm><primary>adgangskode</primary><secondary>glemt</secondary></indexterm>
<indexterm><primary>glemt password</primary></indexterm>
<indexterm><primary>password</primary><secondary>glemt</secondary></indexterm>


<para>
Hvis du har dummet dig meget og glemt din root-adgangskode, så kan du 
få sat en ny ind. 
</para>

<para>
I så fald booter du med "linux init=/bin/sh" . Så starter den en
shell som proces nr. 1. Herefter køres
</para>

<screen>
<PROMPT>[root@linus ~]#</PROMPT> <userinput>mount -n -o remount,rw /</userinput>     # re-mount / read-write
<PROMPT>[root@linus ~]#</PROMPT> <userinput>passwd</userinput>                       # skift adgangskode
<PROMPT>[root@linus ~]#</PROMPT> <userinput>mount -n -o remount,ro /</userinput>     # remount / read-only
<PROMPT>[root@linus ~]#</PROMPT> <userinput>exec /sbin/init 3 </userinput>           # start init i runlevel 3
</screen>

<para>
Dette lyder jo som et stort sikkerhedshul, og det er det også, hvis man
har fysisk adgang til maskinen. Du kan dog undgå dette ved at tilføje 
linien "password=MIT_PASSWORD" til din
<filename>/etc/lilo.conf</filename>, men så skal du kunne huske
root-adgangskoden og den adgangskode, du har sat i <filename>/etc/lilo.conf</filename>.
</para>

</sect1>


<sect1 id="Opstart">
<title>Opstart af Linux</title>
<sect2 ID="NTogLinux">
<title>Samtidig installation af Windows NT og Linux</title>
<indexterm><primary>Opstart af Linux</primary><secondary>NT</secondary></indexterm>
<indexterm><primary>Microsoft Windows</primary><secondary>NT</secondary></indexterm>
<indexterm><primary>Windows</primary><secondary>NT</secondary></indexterm>

<para>
Windows NT og Linux kan sagtens være installeret på samme maskine, det eneste
lidt problematiske er opstarts-proceduren. Du kan
vælge mellem at starte op i LILO's opstarter eller i NT's. 
Det helt ideelle vil være, at begge startprogrammer
kan starte begge systemer. Denne løsning kan man kalde
'den ideelle duét-opstartsløsning'.
</para>

<para>
Når Windows NT installeres, bliver "Master Boot Recorden" (MBR) på
harddisken altid overskrevet, således at NT's egen opstartsindlæser får
kontrol over opstarten af maskinen. Når Linux installeres, får du en
valgmulighed: du kan vælge at overskrive MBR med LILO, eller du kan
vælge at installere LILO på en harddiskpartition.
</para>

<para>
Det er netop det, vi skal udnytte til at duét-opstarte mellem
LILO og Windows NT's "OS Loader".  Vi er ikke interesserede i at miste
muligheden for at starte op i Linux ved hjælp af LILO, så det kan
betragtes som en forebyggende handling at acceptere tingenes
tilstand, det vil sige at placere  Windows NT's "OS Loader" i MBR og
at placere LILO på en passende
primær partition. Derfor skal du svare NEJ til at placere LILO i
"Master Boot Recorden" (MBR). LILO bør i stedet placeres på den primære
partition, Linux er installeret i.
</para>

<para>
Når du vælger at installere LILO på en harddiskpartition i stedet for
i "Master Boot Recorden" (MBR), er det nødvendigt at fremstille en
opstartsdiskette til Linux, enten som en del af installationen eller
efter installationen, men under alle omstændigheder
<emphasis>før</emphasis> Linux lukkes ned. Ellers får du svært ved at
starte op i Linux igen! Opstartsdisketten kan fremstilles efter
installeringen med Linux-kommandoen
<command>mkbootdisk</command>. Husk at have en formateret diskette
parat. Disketten skal være formateret 'unconditional', så der ikke
ligger information skjult på den, for eksempel <command>FORMAT A:
/U</command> i en DOS-prompt eller Linux-kommandoen
<command>fdformat</command>. Det er vigtigt, at disketten er 100% fri
for fysiske fejl!
</para>

<para>
Eksempel:
</para>

<screen>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>fdformat /dev/fd0H1440</USERINPUT>
Double-sided, 80 tracks, 18 sec/track. Total capacity 1440 kB.
Formatting ... done
Verifying ... done
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>ls -l /lib/modules</USERINPUT>
total 1
drwxr-xr-x 10 root root 1024 Dec 1 22:40 2.0.36-0.7
lrwxrwxrwx  1 root root   23 Dec 3 13:22 preferred -> /lib/modules/2.0.36-0.7
</screen>

<para>
<filename>preferred</filename> peger på kataloget 2.0.36-0.7. Det
benyttes i <command>mkbootdisk</command>-kommandoen:
</para>

<screen>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>mkbootdisk 2.0.36-0.7</USERINPUT>
Insert a disk in /dev/fd0. Any information on the disk will be lost.
Press &lt;Enter&gt; to continue or ^C to abort:
</screen>

<para>
Microsoft anbefaler, at C-drevet under Windows NT kører FAT. Det giver
muligheder for fejlfinding, der ikke eksisterer på et NTFS-drev.  En
uventet, men glædelig sideeffekt af dette er, at Linux kan montere
C-drevet. Det giver blandt andet mulighed for den ideelle
duét-opstartsløsning beskrevet i dette afsnit.
</para>

<para>
Standard-installationen af Red Hat Linux konfigurerer automatisk
duét-funktionen for Linux' opstartsystem LILO. Det
eneste, du skal gøre, er at acceptere de to opstartsmuligheder 'dos' eller
'Linux'.  Når LILO starter, kan du trykke på TAB-tasten for at få en
oversigt over opstartsmulighederne. Typisk kan du vælge mellem 'Linux' og
'dos'. Når du vælger 'dos', starter LILO Windows NT's "OS Loader".
</para>

<para>
Det lidt mere omstændelige er konfigurering af Windows NT's "OS Loader", så
LILO kan startes fra Windows NT's "OS Loader". Windows NT's "OS Loader"
benytter sig af filreferencer i filen <filename>C:\BOOT.INI</filename>.
</para>

<para>
Eksempel på BOOT.INI:
</para>

<SCREEN>
[boot loader]
timeout=5
default=multi(0)disk(0)rdisk(0)partition(3)\WINNT
[operating systems]
multi(0)disk(0)rdisk(0)partition(3)\WINNT="NT Workstation 4.00 SP3"
multi(0)disk(0)rdisk(0)partition(3)\WINNT="NT Workstation 4.00 SP3 [VGA mode]" /basevideo /sos
C:\="Windows 95"
</screen>

<para>
Når NT-systemet med denne <filename>BOOT.INI</filename> startes op,
har brugeren fem sekunder til at fravælge standard-opstarten af WINNT.
</para>

<para>
Filen skal nu tilrettes, så Linux også bliver en valgmulighed.
</para>

<para>
Skriv i DOS/NT:
</para>

<screen>
C:
CD \
ATTRIB -s -r BOOT.INI
EDIT BOOT.INI
</screen>

<para>
Tilføj følgende linje:
</para>

<screen>
C:\BOOTSECT.LNX="Linux - Red Hat Distribution 7.x"
</screen>

<para>
Sæt derefter filens attributter igen:
</para>

<screen>
ATTRIB +s +r BOOT.INI
</screen>

<para>
Filen <filename>BOOTSECT.LNX</filename> skal fremstilles fra
Linux. Først skal vi finde 
frem til navnet på Linux-partitionen i Linux. Udfør kommandoen
<command>df</command>. Notér navnet på filsystemet for rod-disken
(<filename>"/"</filename>). I det følgende ses på et eksempel med to
scsi-diske (deraf <filename>sda</filename> og <filename>sdb</filename>).
</para>

<para>
Eksempel:
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>df</USERINPUT>
Filesystem         1024-blocks  Used Available Capacity Mounted on
/dev/sda2             692011  356539   299728     54%   /
/dev/sda1             618288  424384   193904     69%   /dos
/dev/sdb1             208592  196616    11976     94%   /dos2
/dev/sdb3             513808  426136    87672     83%   /dos3
</screen>

<para>
Navnet på Linux-partitionen er forskelligt fra system til system. I
eksemplet ovenfor er navnet på Linux-roddisken 
<filename>/dev/sda2</filename>.  Nu skal
<filename>BOOTSECT.LNX</filename> fremstilles. Dette gøres ved at
kopiere 512 byte fra starten af Linux-partitionen
<filename>/dev/sda2</filename> til filen
<filename>BOOTSECT.LNX</filename>.  Udfør kommandoerne:
</para>

<screen>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT> dd if=/dev/sda2 of=/bootsect.lnx bs=512 count=1</userinput>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT> mv /bootsect.lnx /dos/bootsect.lnx</userinput>
</screen>

<para>
Har du ikke adgang til den DOS-partition, hvor du starter op fra
(eller er den NTFS-formateret), kan du i stedet kopiere filen ud på en
diskette med brug af <command>mcopy</command>.
</para>

<screen>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT> dd if=/dev/sda2 of=/bootsect.lnx bs=512 count=1</userinput>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT> mcopy /bootsect.lnx a:</userinput>
</screen>


<para>
Genstart derefter din maskine. Hvis du vælger at geninstallere LILO i
Linux, skal du huske at fremstille en ny
<filename>BOOTSECT.LNX</filename>-fil. 
</para>


<para>
Nu kan Linux' opstarter startes fra Windows NT's "OS Loader", således at
du <emphasis>kan</emphasis> opnå valgfrihed - også med Windows NT!
</para>

<para>
Hvis du vil vide meget mere om MBR-placering, opstartere og
partitioner, kan det anbefales at læse HOWTO-guiden om LILO. På Red Hat
Linux-cdrommen hedder filen <filename>/doc/HOWTO/mini/LILO</filename>
</para>
</sect2>
</sect1>


<SECT1 ID="runlevel">
<TITLE>Hvad er et "runlevel"?</TITLE>
<indexterm><primary>Runlevels</primary></indexterm>
<indexterm><primary>/etc/rc.d</primary></indexterm>
<indexterm><primary>Start i grafisk tilstand</primary></indexterm>
<PARA>
Et runlevel er den tilstand, som systemet kører i. Computeren kan køre
i tilstande så som "ved at starte systemet", "enkelbrugersystem",
"flerbrugersystem", "genstarter system" og "slukker computeren". Hvis
man f.eks. vil kopiere <filename>/home</filename> kataloget over på en
større harddisk fordi ens brugere har for mange MP3 filer liggende.
Så er det nødvendigt at sikre, at der ikke er nogen brugere, der har
filer åbne, mens man kopierer, idet der så kan opstå en fejl i
kopieringen. Dette kan man sikre sig ved at skifte til
enkeltbruger-tilstand, der svarer lidt til fejlsikret tilstand i
Windows. Når man er færdig med systemarbejdet, hopper man tilbage til
"flerbrugersystem" og folk har igen adgang til computeren, og vil ikke
bemærke at deres filer pludselig ligger på et andet drev.
</para>

<para>
Computeren kører en masse services for brugerne, dette kan
f.eks. være netværksforbindelse (network) og forskellige
netværksrelaterede services som f.eks. e-post
(sendmail/routed/named/snmpd/portmap), adgang til filsystemer på andre
computere (nfs), mulighed for at udskrive til printer (lpd) og
lydkort (sound). Men mens Linux er ved at starte, har man ikke brug
for at have adgang til printeren, så printer-servicen startes først
når systemet går ind i "flerbrugersystem" tilstanden.  Når man er ved
at genstarte eller slukke computeren, slukker man igen for
printer-servicen.</para>

<para> Når computeren omstilles fra en tilstand til en anden tilstand,
udføres en række scripts, der bestemmer hvilke services der skal
tændes og slukkes. Hvilke scripts der kører ved skift til f.eks.
runlevel 3 (Flerbrugersystem), bestemmes af, hvilke scripts der er
placeret i kataloget <filename>/etc/rc.d/rc3.d</filename> (Corel,
Debian og nu også Red Hat 7.0 har tilsvarende
<filename>/etc/rc3.d</filename>).
</PARA>

<SCREEN>
<PROMPT>[anne@linus ~]$ </PROMPT><USERINPUT>ls /etc/rc.d/rc3.d</USERINPUT>
K30mcserv  K40snmpd   K55routed  K75gated  K80random   K95nfsfs
K96pcmcia  K97network S01kerneld S30syslog S40atd      S40crond
S40portmap S50inet    S55named   S60lpd    S75keytable S80sendmail
S85sound   S99local
</SCREEN>

<PARA>
Disse filer svarer til services der skal startes (dem der starter med
S) eller dræbes (starter med K for Kill) når systemets tilstand ændres
til tilstand 3 (Flerbrugersystem). Tallet bestemmer rækkefølgen;
<filename>S01kerneld</filename> startes altså før
<filename>S30syslog</filename>, mens <filename>K96pcmcia</filename>
servicen dræbes efter <filename>K30mcserv</filename>. Hver fil i dette
katalog er i virkeligheden et link til et script i
<filename>/etc/rc.d/init.d/</filename>, og "S80sendmail" betyder i
virkeligheden at "/etc/rc.d/init.d/sendmail start" udføres, hvilket
starter sendmail-dæmonen op.
</PARA>

<PARA>
Det er ikke svært at finde ud af, hvilket runlevel din computer er
i. Nedenfor er vist hvordan.
</PARA>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>/sbin/runlevel</USERINPUT>
N 3
</SCREEN>

<PARA>
3-tallet viser dig, at din PC er i runlevel 3. Det er muligt
at skifte runlevel uden at lukke computeren ned, men N'et
viser, at der intet tidligere runlevel er, dvs. computeren har været i
runlevel 3, siden den blev tændt. Du skifter runlevel
med kommandoen <FILENAME>telinit</FILENAME>. Du bør altid synkronisere 
dine harddiske (tømme filsystemernes buffere) inden du skifter
runlevel, dvs. kør <command>sync</command> et par gange, lige inden du
skifter runlevel med <command>telinit</command>.
</PARA>

<PARA>
Runlevel 3 er det mest almindelige. Skemaet nedenfor viser
betydningen af de forskellige runlevels.
</PARA>

<TABLE frame="all">
  <TITLE>Runlevels</TITLE>
  <TGROUP COLS=2 ALIGN="char">
  <THEAD>
    <ROW>
      <ENTRY>Runlevel</ENTRY>
      <ENTRY>Betydning</ENTRY>
    </ROW>
  </THEAD>
  <TBODY>
    <ROW>
      <ENTRY>0</ENTRY>
      <ENTRY>Lukker systemet ned (<userinput>shutdown -h now</userinput>)</ENTRY>
    </ROW>
    <ROW>
      <ENTRY>1</ENTRY>
      <ENTRY>Enkeltbrugertilstand (Single-user mode)</ENTRY>
    </ROW>
    <ROW>
      <ENTRY>2</ENTRY>
      <ENTRY>Flerbrugertilstand uden NFS</ENTRY>
    </ROW>
    <ROW>
      <ENTRY>3</ENTRY>
      <ENTRY>Flerbrugertilstand med NFS</ENTRY>
    </ROW>
    <ROW>
      <ENTRY>4</ENTRY>
      <ENTRY>Bruges ikke</ENTRY>
    </ROW>
    <ROW>
      <ENTRY>5</ENTRY>
      <ENTRY>Starter op i X11</ENTRY>
    </ROW>
    <ROW>
      <ENTRY>6</ENTRY>
      <ENTRY>Genstart systemet (<userinput>reboot</userinput>)</ENTRY>
    </ROW>
  </TBODY>
</TGROUP>
</TABLE>

<PARA>
Som det fremgår af skemaet, er runlevel 6 det samme som at genstarte
systemet, dvs. når systemadministratoren genstarter systemet ved at
bruge kommandoen <command>reboot</command> (genstart), skiftes der til runlevel
6.
</PARA>

<PARA>
Enkeltbrugertilstand er et meget nyttigt runlevel. Hvis det sker, at du
kommer til at konfigurere et eller andet forkert en dag - ja, det vil ske
på et eller andet tidspunkt! - og din PC låser under
opstarten, kan du starte den op i Enkeltbrugertilstand og foretage diverse
rettelser.
</PARA>

<indexterm><primary>/etc/inittab</primary></indexterm>
<indexterm><primary>runlevel</primary></indexterm>
<indexterm><primary>opstart af Linux</primary></indexterm>

<PARA>
I filen <FILENAME>/etc/inittab</FILENAME> angives, hvilket
runlevel der er det forvalgte runlevel. Ønsker man f.eks. at 
maskinen starter i runlevel 5 og ikke 3, så skal man ændre linien
</para>

<screen>
id:3:initdefault:
</screen>

<para>
til
</para>
<screen>
id:5:initdefault:
</screen>

<para>
Se også <xref linkend="etcrcdfilen"> for detaljer om forskelle mellem
de forskellige Linux-distributioner.
</para>

</SECT1>

<SECT1 ID="Nedlukning">
<TITLE>Nedlukning af Linux</TITLE>
<indexterm><primary>Nedlukning</primary></indexterm>
<indexterm><primary>Reboot</primary></indexterm>
<indexterm><primary>Genstart</primary></indexterm>
<indexterm><primary>Ctrl-Alt-Del</primary></indexterm>
<PARA>
En Linux-maskine er, som du nok allerede har forstået, et meget stort
system med mange muligheder.  Du skal også være meget opmærksom på, at
man (ligesom med en Windows-maskine) ikke bare må slukke for en
Linux-maskine - den skal helst lukkes pænt ned.
</PARA>

<PARA>
Som vi viste i <xref linkend="runlevel">, er runlevel 0 det samme som
at lukke ned. En generel, men lidt besværlig måde at lukke en UNIX-maskine
på, er at skifte til root og skrive <userinput>init 0</userinput>
eller <userinput>telinit 0</userinput>
</para>

<SCREEN>
<PROMPT>[anne@linus ~]$ </PROMPT><USERINPUT>su -</USERINPUT>
Passwd: <USERINPUT>hemlig</USERINPUT>
<PROMPT>[root@linus /root]# init 0</PROMPT>
</SCREEN>

<indexterm><primary>Ctrl-Alt-Delete</primary></indexterm>

<para>
En hurtig nedlukning fås ved at trykke
"Ctrl-Alt-Delete", når du er i en tekstkonsol - f.eks. efter du
trykker "Ctrl-Alt-F1".
</para>

<para>
Du skal dog en gang for alle lave en ændring, så "Ctrl-Alt-Delete"
kommer til at medføre at Linux lukkes ned. Ændres intet, genstarter
systemet.  For at få maskinen til at stoppe
kaldes <command>/sbin/halt</command>, og skal du ændre i
<FILENAME>/etc/inittab</FILENAME>
</para>

<SCREEN>
# Trap CTRL-ALT-DELETE
ca::ctrlaltdel:/sbin/shutdown -t3 -r now
</SCREEN>

<para>
så der kommer til at stå
</para>

<SCREEN>
# Trap CTRL-ALT-DELETE
ca::ctrlaltdel:/sbin/shutdown -t3 -h now
</SCREEN>

<para>
Du kan selvfølgelig være fræk, så maskinen slet ikke kan stoppes fra
tastaturet med "Ctrl-Alt-Delete", f.eks. kan du
ændre <FILENAME>/etc/inittab</FILENAME> til
</para>

<SCREEN>
# Trap CTRL-ALT-DELETE
ca::ctrlaltdel:echo "No reboot for you my friend!\n"
</SCREEN>

<para>
Dette er uhyre praktisk, hvis din maskine står et sted, hvor der er
mange pilfingre, f.eks. edb-lokalet på en skole!
</PARA>
</sect1>

<sect1 id="crontab">
<title>Crontab</title>
<indexterm><primary>Cron</primary><secondary>crontab</secondary></indexterm>
<para>
Crontab er et smart system til automatisk at køre programmer på givne
tidspunkter, såsom daglig backup. Det er en standarddel af et
UNIX-system og er derfor altid med i Linux.
</para>

<para>
Man kan få kørt vilkårlige programmer på vilkårlige tidspunkter,
f.eks. hvert minut, hver time, hver dag, ugedag eller månedsdag.  I filen
<filename>/etc/crontab</filename> retter man normalt ikke, men denne
fil viser, at der køres jobs hver time fra
<filename>/etc/cron.hourly</filename> til tilsvarende hver dag, uge og
måned via <filename>/etc/cron.daily</filename>,
<filename>/etc/cron.monthly</filename> og
<filename>/etc/cron.weekly</filename>.  For en almindelig bruger er
det normalt, at man føjer de kommandoer man vil have kørt på et givet
tidspunkt, til filen <filename>~/.crontab</filename> og kører
kommandoen <command>crontab ~/.crontab</command>.
</para>

<para>
Syntaksen for alle disse crontab-filer er den samme: En kommando per linje
og i rækkefølge fra venstre mod højre, minut (0-59), time (0-23),
månedsdag (0-31), måned (0-12), ugedag (0-7, hvor 0 og 7 begge er søndag)
og endelig den kommando du vil have udført. Hvert felt adskilles af et
mellemrum, og hvis man vil have, at f.eks. alle dage køres
programmet, så indsæt en "*" for månedsdag og måned.</para>

<para> Vi giver nu et eksempel, hvor vi hver morgen kl. 7 fra mandag
til fredag sender brugeren "root" et brev med, hvor meget belastning 
der er på maskinen.
<screen>
0 7 * * 1-5 uptime | mail root
</screen>
Brug <command>man -a crontab</command> til at læse mere om
crontab. Skift til næste man-fil ved at trykke 'q'.
</para>
</sect1>





<SECT1 ID="sikkopi">
<!-- Skrevet af Claus Sørensen "cs@klid.dk" -->

<TITLE>Sikkerhedskopiering</TITLE>
<indexterm>
 <primary>Sikkerheds-kopiering</primary>
</indexterm>
<indexterm>
 <primary>Backup</primary>
</indexterm>

<para>
En vigtig del af systemadministration er sikkerhedskopiering, 
så man i tilfælde af nedbrud, harddiskcrash, brand 
eller andre uheld kan fortsætte uden større tab af data.
</para>

<para>
Sikring af ens data kan ske på flere måder, hvilket selvfølgelig er
afhængigt af den grad af sikkerhed man ønsker, samt mængden af data,
som skal sikres.
</para>

<SECT2 ID="sikkopi-metoder">
<TITLE>Metoder for sikkerhedskopiering</TITLE>
<para>
Grundlæggende kan man dele sikkerhedskopiering op i lokal- 
og fjernkopiering, hvilket bestemmes af det omfang af 
sikring som ønskes samt de tekniske muligheder som 
forelægger eller investering i samme.
</para>

<sect3 id="sikkopi-lokal">
<TITLE>Lokal sikkerhedskopiering</TITLE>

<para>
Lokal sikkerhedskopiering sker ved at man
gemmer kopier af sine data på samme sted, som dataerne
er på. Her benyttes oftest disketter, bånd, brændbare 
cdrommer eller udskiftelige harddiske som lagringsmedier.
</para>
</sect3>

<sect3 id="sikkopi-fjern">
<TITLE>Sikkerhedskopiering via Internettet</TITLE>

<para>
Fjernkopiering sker ved, at man aftaler med andre, 
at de krypteret spejler ens data samtidig med, at man 
gør det samme med deres. Det kræver selvfølgelig en 
tro på dem, som man udveksler data med, selvom dataene 
er krypterede.
</para>

<para>
Fjernkopiering er blevet mere aktuel efter at 
højhastighedsforbindelser (ADSL m.v.) er kommet ned i et 
prisleje, hvor også private og mindre virksomheder kan 
være med.
</para>

<para>
Man nøjes med at kopiere de forskelle, som er sket siden 
sidst, så man belaster forbindelsen mindst muligt. Hvis 
man ikke stoler blindt på den, som giver plads til ens 
sikkerhedskopi, kan man altid kryptere dataene med 
GnuPG eller lignende krypteringsværktøjer.
</para>
</sect3>

<sect3 id="sikkopi-hvad">
<TITLE>Hvad skal kopieres?</TITLE>


<para>
Generelt skal man gemme de data, som man ikke kan 
undvære, og som er umulige at fremskaffe på anden vis f.eks. 
via installation.
</para>

<para>
Dette kan være en af baggrundene for at dele et Linux-system op i
flere partitioner, da visse værktøjer netop sikkerhedskopierer efter
partitioner. De vigtigste kataloger er <filename>/home</filename>
(brugerdata), <filename>/var</filename> (serverdata) og
<filename>/etc</filename> (konfigurationsdata), som således også bør
have deres egne partitioner.
</para>

</sect3>



</SECT2>

<SECT2 ID="sikkopiprog">
<TITLE>Værktøjer til sikkerhedskopiering</TITLE>
<indexterm>
 <primary>Sikkerheds-kopiering</primary>
 <secondary>Værktøjer</secondary>
</indexterm>

<para>
Valget af værktøj til sikkerhedskopiering er afhængigt 
af en lang række faktorer så som lagringsmedie, 
type af adgang til systemet, graden af automation 
og omfanget af data.
</para>

<para>
I de næste afsnit vil forskellige værktøjer kort blive 
gennemgået, hvor deres fordele og ulemper vil blive 
belyst. Listen er på ingen måde udtømmende, men kan 
benyttes som et meget hurtigt overblik over de muligheder, 
som findes til sikkerhedskopiering i et Linux-miljø.
</para>

<sect3 id="sikkopi-tar">
<TITLE>Sikkerhedskopiering med tar</TITLE>
<indexterm>
 <primary>tar</primary>
</indexterm>
<indexterm>
 <primary>Sikkerheds-kopieringsværktøjer</primary>
 <secondary>tar</secondary>
</indexterm>
<para>
Den mest benyttede kommando til sikkerhedskopiering er 
<command>tar</command>, som er en forkortelse for Tape 
ARchive. <command>tar</command> samler blot filer og 
deres data sammen i en enkelt fil, som så kan gemmes 
på et medie til sikkerhedskopiering f.eks. et bånd.
</para>

<para>
Hvis du vil tage en sikkerhedskopi på disketter af 
alle filerne i kataloget <filename>/home</filename> 
gøres det således:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>tar -cMf /dev/fd0H1440 /home</userinput>
</screen>

<para>Hvor <command>-cMf</command> står for henholdsvis 
oprette (<command>c</command>reate), 
på flere medier (<command>m</command>ultiple) 
og viser hvilke filer (<command>f</command>iles).
</para>

<para> 
Når der ikke er mere plads på den første diskette, 
spørger programmet automatisk efter den næste.
</para>

<para>Hver gang man har foretaget en sikkerhedskopiering, 
skal man huske at kontrollere den, så man er sikker på, 
at man kan genskabe dataene fra sikkerhedskopien. Dette 
gøres således:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>tar -compare -verbose -f /dev/fd0H1440</userinput>
/home
/home/alle
/home/alle/annoncetekst.txt
....
</screen>

<para>
I stedet for de lange tilvalg kan benyttes de kortere
udgaver, hvilket kan ses af man-siden for 
<command>tar</command>.
</para>

<para>Skal man genskabe dataene igen, så er det ligetil:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>tar -extract -same-permissions -verbose -file /dev/fd0H1440</userinput>
/home
/home/alle
/home/alle/annoncetekst.txt
....
</screen>


<para>
Se mere ved hjælp af man-siden 
(<command>man tar</command>) eller i afsnittet om 
sikkerhedskopiering i 
"The Linux System Administrators' Guide":
<ulink url="http://www.linuxdoc.org/LDP/sag/index.html">http://www.linuxdoc.org/LDP/sag/index.html</ulink>. 
</para>

</sect3>

<sect3 id="sikkopi-dump">
<TITLE>Sikkerhedskopiering med dump og restore</TITLE>
<indexterm>
 <primary>dump</primary>
</indexterm>

<indexterm>
 <primary>restore</primary>
</indexterm>

<indexterm>
<primary>Sikkerheds-kopieringsværktøjer</primary>
 <secondary>dump</secondary>
</indexterm>

<indexterm>
<primary>Sikkerheds-kopieringsværktøjer</primary>
 <secondary>restore</secondary>
</indexterm>

<para>
Hvis man benytter Linux-filsystemet ext2, kan man 
benytte kommandoen <command>dump</command> til at 
gemme sikkerhedskopier helt eller delvist af hele 
filsystemet. De genskabes igen med kommandoen 
<command>restore</command>.
</para>

<para>
Som standard gemmer den kun de forskelle, som er 
opstået siden sidste sikkerhedskopiering, men den kan sættes 
til at tage en kopiering af det hele. 
</para>

<para>
Første gang man gemmer (samt med betryggende 
mellemrum) tages en sikkerhedskopi af alle filerne i 
en partition. Lad os sige at <filename>/home</filename> 
ligger på partition <filename>/dev/hda6</filename>, så 
ser det sådan ud:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>dump -u0 -f /dev/st0 /home</userinput>
</screen>

<para>
Genskabelsen af data sker ved, at man først genskaber 
filsystemet på den partition, som skal genskabes:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>mke2fs /dev/hda6</userinput>
<prompt>[root@linus /root]#</prompt> <userinput>mount /dev/hda6 /mnt</userinput>
<prompt>[root@linus /root]#</prompt> <userinput>cd /mnt</userinput>
</screen>

<para>
Så den bliver klar til at genskabe de data, som 
ligger i sikkerhedskopien:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>restore rf /dev/st0</userinput>
</screen>

<para>
Efter genskabelsen skal <filename>/home</filename> 
monteres igen:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>mount /mnt/home</userinput>
</screen>


<para>
Se mere om <command>dump</command> og 
<command>restore</command> ved at bruge deres 
man-sider.
</para>
</sect3>

<sect3 id="sikkopi-afio">
<TITLE>Sikkerhedskopiering med afio</TITLE>
<indexterm>
 <primary>Sikkerheds-kopieringsværktøjer</primary>
 <secondary>afio</secondary>
</indexterm>

<para>
Hvis man gerne vil have adgang til filerne individuelt 
efter sikkerhedskopieringen, kan man benytte værktøjet 
<command>afio</command>, som blandt andet bliver 
benyttet af KBackup.
</para>

<para>
Læs mere med <command>man afio</command>.
</para>

</sect3>

<sect3 id="sikkopi-kbackup">
<TITLE>Sikkerhedskopiering med KBackup</TITLE>
<indexterm>
 <primary>Sikkerheds-kopieringsværktøjer</primary>
 <secondary>KBackup</secondary>
</indexterm>

<para>
KBackup en alsidig applikation til håndtering af 
sikkerhedskopiering bygget oven på andre 
værktøjer blandt andet <command>tar</command> og 
<command>afio</command>.
</para>

<para>
Den menubaserede grænseflade er meget intuitiv 
at bruge, så man nemt får sat en god rutine op 
for sikkerhedskopiering af de data, man selv 
ønsker.
</para>

<para>
Flere informationer kan findes på KBackups 
hjemmeside: <ulink url="http://kbackup.sourceforge.net">http://kbackup.sourceforge.net</ulink>
</para>

</sect3>

<sect3 id="sikkopi-arkeia">
<TITLE>Sikkerhedskopiering med Arkeia</TITLE>
<indexterm>
 <primary>Sikkerheds-kopieringsværktøjer</primary>
 <secondary>Arkeia</secondary>
</indexterm>

<para>
Arkeia er et meget professionelt grafisk værktøj 
til håndtering af sikkerhedskopiering. Det er 
desværre closed sourced, men gratis også for 
virksomheder at bruge til en server og to klienter.
</para>

<para>
Hent vejledningen og programmet fra deres 
hjemmeside:
<ulink url="http://www.arkeia.com/">http://www.arkeia.com/</ulink>
og installér det.
</para>
</sect3>

<sect3 id="sikkopi-windows">
<TITLE>Microsoft Windows-værktøjer via Samba</TITLE>
<indexterm>
 <primary>Sikkerheds-kopieringsværktøjer</primary>
 <secondary>Til Microsoft Windows</secondary>
</indexterm>
<para>
Ligger ens data på en Samba-server, kan man i de fleste 
tilfælde bruge de Microsoft Windows-værktøjer, som 
følger med båndstation eller anden hardware til 
sikkerhedskopiering. Man skal så blot huske at oprette 
en sti til lagringsmediet i konfigurationsfilen til 
Samba (<filename>/etc/smb.conf</filename>).
</para>
</sect3>

</sect2>



</sect1>

<SECT1 ID="sysadm-afslutning">
<TITLE>Tips og tricks</TITLE>

<PARA>
Der er meget mere i systemadministration, end dette korte kapitel har
præsenteret. Til Linux findes der især to dokumenter, som er gode at
læse, nemlig "System Administrator's Guide" (SAG) og "Network
Administrator's Guide" (NAG) - begge kan hentes fra 
<ulink url="http://sunsite.dk/ldp">http://sunsite.dk/ldp</ulink> og
findes på din Red Hat cdrom. De er en del af "Linux
Documentation Project" (LDP). Red Hat's hjemmeside indeholder endvidere
en række gode tricks og nyttige oplysninger. De bedste bøger om UNIX
systemadministration er uden tvivl Æleen Frisch's "Essential System
Administration" udgivet af O'Reilly, og "UNIX System Administration
Handbook" (Evi Nemeth, Garth Snyder, Scott Seebass og Trent R. Hein) udgivet
af Prentice Hall PTR.
</PARA>

<para>
Vil du vide mere om sikkerhedskopiering 
under Linux, så kig i 
"The Linux System Administrators' Guide":
<ulink url="http://www.linuxdoc.org/LDP/sag/index.html">http://www.linuxdoc.org/LDP/sag/index.html</ulink>. 
</para>


</SECT1>
</chapter>
