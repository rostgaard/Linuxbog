<!-- $Id$ -->
<chapter id="sysadm">
<title>Systemadministration</title>

<para>
I dette kapitel ser vi nærmere på nogle af de værktøjer og opgaver som
systemadministratoren kommer ud for.
</para>


<sect1 id="glemt-passwd">
<title>Har du glemt din adgangskode?</title>

<indexterm><primary>adgangskode</primary><secondary>glemt</secondary></indexterm>
<indexterm><primary>glemt password</primary></indexterm>
<indexterm><primary>password</primary><secondary>glemt</secondary></indexterm>


<para>
Hvis du har dummet dig meget og glemt din root-adgangskode, så kan du 
få sat en ny ind. 
</para>

<para>
I så fald booter du med "linux init=/bin/sh" . Så starter den en
shell som proces nr. 1. Herefter køres
</para>

<screen>
<PROMPT>[root@linus ~]#</PROMPT> <userinput>mount -n -o remount,rw /</userinput>     # re-mount / read-write
<PROMPT>[root@linus ~]#</PROMPT> <userinput>passwd</userinput>                       # skift adgangskode
<PROMPT>[root@linus ~]#</PROMPT> <userinput>mount -n -o remount,ro /</userinput>     # remount / read-only
<PROMPT>[root@linus ~]#</PROMPT> <userinput>exec /sbin/init 3 </userinput>           # start init i runlevel 3
</screen>

<para>
Dette lyder jo som et stort sikkerhedshul, og det er det også, hvis man
har fysisk adgang til maskinen. Du kan dog undgå dette ved at tilføje 
linien "password=MIT_PASSWORD" til din
<filename>/etc/lilo.conf</filename>, men så skal du kunne huske
root-adgangskoden og den adgangskode, du har sat i <filename>/etc/lilo.conf</filename>.
</para>

</sect1>






















<sect1 id="Opstart">
<title>Opstart af Linux</title>
<sect2 ID="NTogLinux">  <!-- ikke længere specifikt for NT Windows -->
<title>Samtidig installation af Windows og Linux</title>
<indexterm><primary>Opstart af
Linux</primary><secondary>Windows</secondary></indexterm>
<indexterm><primary>Microsoft
Windows</primary><secondary>Windows</secondary></indexterm>
<indexterm><primary>Dual
Boot</primary><secondary>Linux</secondary></indexterm>

<para>
Windows og Linux kan sagtens være installeret på samme
computer. Ved at bruge et opstartsprogram kan man, når
man starter computeren, vælge om den skal køre Linux
eller Windows. Det er således muligt at have flere Windows
og Linux kerne-versioner installeret samtidigt på en
computer, man kan dog kun køre en af dem af gangen!
</para>

<para>
Når man starter en computer, der kun har Windows installeret
indlæses først opstartsprogrammet, der ligger i Master Boot
Record (MBR), der ligger i starten af den første harddisk
(/dev/hda) sammen med partitionstabellen. Opstartsprogrammet
i MBR overfører kontrollen til et opstartsprogram, der ligger
i boot-sektoren på den første partition af harddisken (/dev/hda1).
Hvis computeren kører Windows 95 eller 98 vil DOS blive startet,
og DOS starter automatisk Windows. Kører computeren Windows NT
eller 2000 giver opstartsprogrammet et valg mellem hvilken
konfiguration af operativ systemet man ønsker at anvende, og
starter så Windows.
</para>

<!-- Flyt følgende para til FTAV begynder bogen? -->

<para>
Microsoft anbefaler, at C-drevet under Windows NT kører FAT.
Det giver muligheder for fejlfinding, der ikke eksisterer på
et NTFS-drev. En uventet, men glædelig sideeffekt af dette
er, at Linux kan montere C-drevet. En anden fordel er at hvis
Windows fylder hele harddisken, så kan man bruge DOS programmet
fips.exe frigøre en del af Windows partition til en Linux
partition. Det er derimod ikke muligt at frigøre en del af en
NTFS partition, og i såfald er det nødvendigt at slette windows,
repartitionere og geninstallere Windows på en mindre partition.
</para>

<para>
Når man først starter en computer, der kun har Linux installeret,
startes LInux-LOaderen (LILO), der ligger i MBR (der findes dog
også en række andre opstartsprogrammer end LILO til Linux). LILO
giver brugeren mulighed for at vælge hvilken kerne-version, der
skal startes op. På den måde er det for eksempel muligt teste en
ny-oversat kerne, og hvis den ikke virker kan man bare
genstarte, og vælge en gammel og gennemprøvet kernel.
</para>

<para>
Hvis det er Windows' opstartsprogram der ligger i MBR, skal
Windows konfigurationen ændres så den kan starte Linux. Hvis
det er Linux' opstartsprogram der ligger i MBR skal Lilo's
konfiguration ændres, så den kan starte Windows op. De følgende
sektioner vil gennemgå begge muligheder. 
</para>

<para>
Bemærk at hvis Windows (gen)installeres, bliver MBR på
harddisken overskrevet! Hvis LILO er installeret i MBR vil den 
derfor blive slettet, og man kan ikke starte Linux op.
Det er derfor meget vigtigt at lave en opstarts-diskette (eng. Boot disk) til Linux,
før man vil geninstallere Windows. Det er også smart at lave
en opstarts-diskette før man begynder at eksperimentere med LILO, således
at det er muligt at rede sig ud af en fejl konfiguration, der
gør at computeren vil boote Linux og/eller Windows.
</para>

<para>
Opstartsdisketten kan fremstilles efter installeringen med
Linux-kommandoen <command>mkbootdisk</command>. Husk at
have en formateret diskette parat. Det er vigtigt, at
disketten er 100% fri for fysiske fejl!
</para>

<para>
Eksempel:
</para>

<screen>
<PROMPT>[root@linus /root]# </PROMPT>
<USERINPUT>fdformat /dev/fd0H1440</USERINPUT>
Double-sided, 80 tracks, 18 sec/track. Total capacity 1440 kB.
Formatting ... done
Verifying ... done
<PROMPT>[root@linus /root]# </PROMPT>
<USERINPUT>mkbootdisk `uname --release`</USERINPUT>
Insert a disk in /dev/fd0. Any information on the disk will be lost.
Press &lt;Enter&gt; to continue or ^C to abort:
</screen>

<!-- Eksemplet er noget simplificeret sammenlignet med det gamle,
     men kræver at kernen ligger i /boot -->

<para>
Det er også en smart ide at lave en boot disk til Windows før du
går igang med LILO eksperimenter. Med Windows 95 og 98 kan man køre
<command>format a: /s</command> på kommando linien. For Windows NT
og 2000 skal disketten formateres, dette er vigtigt da det opretter
en Windows boot sektor på disketten, og filerne 
<filename>ntldr</filename>,
<filename>Ntdetect.com</filename> og <filename>Boot.ini</filename>
kopieres
fra roden af C: drevet til disketten. Filerne er normalt mærket som
skjulte og system, så du skal muligvis ændre Explorens konfiguration
for at finde dem.
</para>

<sect3 ID="LinuxiMBR">
<title>Linux kontrollere opstarten</title>

<para>
Den letteste løsning er at lade Linux kontrollere opstarten.
Det ser også mest blæret ud :-)
</para>

<para>
Under installationen af Red Hat gøres dette ved at installere
LILO i MBR. Under Red Hat installationen vil et Windows partition
automatisk tilføjet til LILO.
</para>

<para>
Har du allerede installeret Linux, kan et Windows operativ system
tilføjes til LILO's opstartsmenu ved at addere følgende linier
til <filename>/etc/lilo.conf</filename>.
</para>

<screen>
other=/dev/hda1
        label=dos
        table=/dev/hda
</screen>

<para>
Husk! Hver gang LILO rekonfigureres skal <command>/sbin/lilo</command> køres som root.
Den vil så opdatere opstartsprogrammet, der ligger i MBR.
</para>

<para>
Når LILO starter får du en oversigt over opstartsmulighederne.
Typisk kan du vælge mellem 'Linux' og 'dos'. Når du vælger 'dos',
starter LILO Windows "OS Loader". I ældre Red Hat versioner
skal der trykkes TAB-tasten for en menu af valgmuligheder.
</para>

</sect3>



<sect3 ID="WindowsiMBR">
<title>Windows kontrollere opstarten</title>

<para>
Dette er ikke muligt med Windows 95 og Windows 98. For disse 
versioner af Windows skal Linux kontrollere opstarten som
beskrevet i det tidligere sektion. Det er mere omstændeligt at
konfigurere Windows NT eller 2000's opstartsprogram "OS Loader".
"OS Loader" konfiguration ligger i filen <filename>C:\Boot.ini</filename>.
</para>

<para>
Når Windows kontrollere opstarten skal LILO installeres
i boot sektoren på root eller /boot partitionen. For at
kunne boote linux fra Windows skal boot-sektoren gemmes
i en fil, overføres til c-drevet og adderes til
<filename>C:\Boot.ini</filename>.
</para>

<para>
Først skal bootsektoren gemmes som en fil fx.
<filename>bootsect.lnx</filename>. I <filename>/etc/lilo.conf</filename>
står en linie "boot=..." denne fortæller i hvilken partition
som LILO's boot sektor er installeret i.
</para>

<para>
Eksempel:
</para>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>grep "^boot" /etc/lilo.conf</USERINPUT>
boot=/dev/hda3
</screen>

<para>
Dette fortæller at LILO er installeret på i boot sektoren på /dev/hda3
partitionen. Bootsektoren kan nu gemmes i en fil
<filename>bootsect.lnx</filename> ved at udføre kommandoen:
</para>

<screen>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT> dd if=/dev/hda3
of=/bootsect.lnx bs=512 count=1</userinput>
</screen>

<para>
Bootsektor filen skal nu kopieres til Windows' C: drev.
Og følgende linie skal adderes til <filename>c:\Boot.ini</filename>.
</para>

<screen>
C:\bootsect.lnx="Linux - Red Hat Distribution 7.x"
</screen>

<para>
Dette betyder at NT's opstartsprogram kører Linux opstartsprogrammet i
bootsect.lnx filen den du vælger Linux i start menuen. Dette trick kan
også udføres med flere boot sektorer.
</para>

<para>
Hvis C: drevet er i FAT-format, kan du monteres
det på root drevet de første to linier i følgende gør netop dette.
De to sidste linier kopieres boot-sektoren til Windows-drevet,
og addere (bemærk at &gt;&gt; <emphasis>skal</emphasis> bruges, da > ville
overskrive filen og ikke addere til den) linien til Boot.ini:
</para>

<screen>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT> mkdir /dos</userinput>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT> mount -t vfat /dev/hda1 /dos</userinput>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT> mv /bootsect.lnx /dos/bootsect.lnx</userinput>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT> echo 'C:\\bootsect.lnx="Linux - Red Hat Distribution 7."' >>/dos/BOOT.INI</userinput>
</screen>

<!-- er der en bedre måde at skrive echo på?? -->

<para>
Dette virker ikke hvis dit Windows drev er NTFS formateret. Har du
afgang til en ftp server, kan du sende <filename>bootsect.lnx</filename>
til FTP serveren, genstarte Windows og hente filen igen. Et
alternativ er at kopiere filen ud på en diskette med brug af
<command>mcopy</command>, som vist i følgende eksempel:
</para>

<screen>
<PROMPT>[root@linus /root]#</PROMPT> <USERINPUT>mcopy /bootsect.lnx a:</userinput>
</screen>

<para>
Genstart derefter din maskine.
</para>

<para>
Eksempel på Boot.ini:
</para>

<SCREEN>
[boot loader]
timeout=5
default=multi(0)disk(0)rdisk(0)partition(3)\WINNT
[operating systems]
multi(0)disk(0)rdisk(0)partition(3)\WINNT="NT Workstation 4.00 SP3"
multi(0)disk(0)rdisk(0)partition(3)\WINNT="NT Workstation 4.00 SP3 [VGA
mode]" /basevideo /sos
C:\="Windows 95"
</screen>

<para>
Denne fil er NT opstartsprogrammets analog til LILO's konfigurationsfil.
Filen skal nu tilrettes, så Linux også bliver en valgmulighed.
</para>

<para>
Skriv i DOS/NT:
</para>

<screen>
C:
CD \
ATTRIB -s -r BOOT.INI
EDIT BOOT.INI
</screen>

<para>
Tilføj følgende linje:
</para>

<screen>
C:\bootsect.lnx="Linux - Red Hat Distribution 7.x"
</screen>

<para>
Sæt derefter filens attributter igen:
</para>

<screen>
ATTRIB +s +r BOOT.INI
</screen>

<para>
Nu kan Linux' opstarter startes fra Windows "OS Loader", således at
du <emphasis>kan</emphasis> opnå valgfrihed - også med Windows!
Husk hvis du vælger at geninstallere LILO i Linux, skal du huske at
fremstille en ny <filename>bootsect.lnx</filename>-fil, og kopiere
den til Windows-partitionen. 
</para>

<para>
Hvis du vil vide meget mere om MBR-placering, opstart og
partitioner, kan det anbefales at læse HOWTO-guiden om LILO. På Red Hat
Linux-cdrommen hedder filen <filename>/doc/HOWTO/mini/LILO</filename>
</para>

<!-- Man kunne også referere til Mini HOWTO'en om NT windows og linux
-->

</sect3>
</sect2>
</sect1>


<SECT1 ID="runlevel">
<TITLE>Hvad er et "runlevel"?</TITLE>
<indexterm><primary>Runlevels</primary></indexterm>
<indexterm><primary>/etc/rc.d</primary></indexterm>
<indexterm><primary>Start i grafisk tilstand</primary></indexterm>
<PARA>
Et runlevel er den tilstand, som systemet kører i. Computeren kan køre
i tilstande så som "ved at starte systemet", "enkelbrugersystem",
"flerbrugersystem", "genstarter system" og "slukker computeren". Hvis
man f.eks. vil kopiere <filename>/home</filename> kataloget over på en
større harddisk fordi ens brugere har for mange MP3 filer liggende.
Så er det nødvendigt at sikre, at der ikke er nogen brugere, der har
filer åbne, mens man kopierer, idet der så kan opstå en fejl i
kopieringen. Dette kan man sikre sig ved at skifte til
enkeltbruger-tilstand, der svarer lidt til fejlsikret tilstand i
Windows. Når man er færdig med systemarbejdet, hopper man tilbage til
"flerbrugersystem" og folk har igen adgang til computeren, og vil ikke
bemærke at deres filer pludselig ligger på et andet drev.
</para>

<para>
Computeren kører en masse services for brugerne, dette kan
f.eks. være netværksforbindelse (network) og forskellige
netværksrelaterede services som f.eks. e-post
(sendmail/routed/named/snmpd/portmap), adgang til filsystemer på andre
computere (nfs), mulighed for at udskrive til printer (lpd) og
lydkort (sound). Men mens Linux er ved at starte, har man ikke brug
for at have adgang til printeren, så printer-servicen startes først
når systemet går ind i "flerbrugersystem" tilstanden.  Når man er ved
at genstarte eller slukke computeren, slukker man igen for
printer-servicen.</para>

<para> Når computeren omstilles fra en tilstand til en anden tilstand,
udføres en række scripts, der bestemmer hvilke services der skal
tændes og slukkes. Hvilke scripts der kører ved skift til f.eks.
runlevel 3 (Flerbrugersystem), bestemmes af, hvilke scripts der er
placeret i kataloget <filename>/etc/rc.d/rc3.d</filename> (Corel,
Debian og nu også Red Hat 7.0 har tilsvarende
<filename>/etc/rc3.d</filename>).
</PARA>

<SCREEN>
<PROMPT>[anne@linus ~]$ </PROMPT><USERINPUT>ls /etc/rc.d/rc3.d</USERINPUT>
K30mcserv  K40snmpd   K55routed  K75gated  K80random   K95nfsfs
K96pcmcia  K97network S01kerneld S30syslog S40atd      S40crond
S40portmap S50inet    S55named   S60lpd    S75keytable S80sendmail
S85sound   S99local
</SCREEN>

<PARA>
Disse filer svarer til services der skal startes (dem der starter med
S) eller dræbes (starter med K for Kill) når systemets tilstand ændres
til tilstand 3 (Flerbrugersystem). Tallet bestemmer rækkefølgen;
<filename>S01kerneld</filename> startes altså før
<filename>S30syslog</filename>, mens <filename>K96pcmcia</filename>
servicen dræbes efter <filename>K30mcserv</filename>. Hver fil i dette
katalog er i virkeligheden et link til et script i
<filename>/etc/rc.d/init.d/</filename>, og "S80sendmail" betyder i
virkeligheden at "/etc/rc.d/init.d/sendmail start" udføres, hvilket
starter sendmail-dæmonen op.
</PARA>

<PARA>
Det er ikke svært at finde ud af, hvilket runlevel din computer er
i. Nedenfor er vist hvordan.
</PARA>

<SCREEN>
<PROMPT>[root@linus /root]# </PROMPT><USERINPUT>/sbin/runlevel</USERINPUT>
N 3
</SCREEN>

<PARA>
3-tallet viser dig, at din PC er i runlevel 3. Det er muligt
at skifte runlevel uden at lukke computeren ned, men N'et
viser, at der intet tidligere runlevel er, dvs. computeren har været i
runlevel 3, siden den blev tændt. Du skifter runlevel
med kommandoen <FILENAME>telinit</FILENAME>. Du bør altid synkronisere 
dine harddiske (tømme filsystemernes buffere) inden du skifter
runlevel, dvs. kør <command>sync</command> et par gange, lige inden du
skifter runlevel med <command>telinit</command>.
</PARA>

<PARA>
Runlevel 3 er det mest almindelige. Skemaet nedenfor viser
betydningen af de forskellige runlevels.
</PARA>

<TABLE frame="all">
  <TITLE>Runlevels</TITLE>
  <TGROUP COLS=2 ALIGN="char">
  <THEAD>
    <ROW>
      <ENTRY>Runlevel</ENTRY>
      <ENTRY>Betydning</ENTRY>
    </ROW>
  </THEAD>
  <TBODY>
    <ROW>
      <ENTRY>0</ENTRY>
      <ENTRY>Lukker systemet ned (<userinput>shutdown -h now</userinput>)</ENTRY>
    </ROW>
    <ROW>
      <ENTRY>1</ENTRY>
      <ENTRY>Enkeltbrugertilstand (Single-user mode)</ENTRY>
    </ROW>
    <ROW>
      <ENTRY>2</ENTRY>
      <ENTRY>Flerbrugertilstand uden NFS</ENTRY>
    </ROW>
    <ROW>
      <ENTRY>3</ENTRY>
      <ENTRY>Flerbrugertilstand med NFS</ENTRY>
    </ROW>
    <ROW>
      <ENTRY>4</ENTRY>
      <ENTRY>Bruges ikke</ENTRY>
    </ROW>
    <ROW>
      <ENTRY>5</ENTRY>
      <ENTRY>Starter op i X11</ENTRY>
    </ROW>
    <ROW>
      <ENTRY>6</ENTRY>
      <ENTRY>Genstart systemet (<userinput>reboot</userinput>)</ENTRY>
    </ROW>
  </TBODY>
</TGROUP>
</TABLE>

<PARA>
Som det fremgår af skemaet, er runlevel 6 det samme som at genstarte
systemet, dvs. når systemadministratoren genstarter systemet ved at
bruge kommandoen <command>reboot</command> (genstart), skiftes der til runlevel
6.
</PARA>

<PARA>
Enkeltbrugertilstand er et meget nyttigt runlevel. Hvis det sker, at du
kommer til at konfigurere et eller andet forkert en dag - ja, det vil ske
på et eller andet tidspunkt! - og din PC låser under
opstarten, kan du starte den op i Enkeltbrugertilstand og foretage diverse
rettelser.
</PARA>

<indexterm><primary>/etc/inittab</primary></indexterm>
<indexterm><primary>runlevel</primary></indexterm>
<indexterm><primary>opstart af Linux</primary></indexterm>

<PARA>
I filen <FILENAME>/etc/inittab</FILENAME> angives, hvilket
runlevel der er det forvalgte runlevel. Ønsker man f.eks. at 
maskinen starter i runlevel 5 og ikke 3, så skal man ændre linien
</para>

<screen>
id:3:initdefault:
</screen>

<para>
til
</para>
<screen>
id:5:initdefault:
</screen>

<para>
Se også <xref linkend="etcrcdfilen"> for detaljer om forskelle mellem
de forskellige Linux-distributioner.
</para>

</SECT1>

<SECT1 ID="Nedlukning">
<TITLE>Nedlukning af Linux</TITLE>
<indexterm><primary>Nedlukning</primary></indexterm>
<indexterm><primary>Reboot</primary></indexterm>
<indexterm><primary>Genstart</primary></indexterm>
<indexterm><primary>Ctrl-Alt-Del</primary></indexterm>
<PARA>
En Linux-maskine er, som du nok allerede har forstået, et meget stort
system med mange muligheder.  Du skal også være meget opmærksom på, at
man (ligesom med en Windows-maskine) ikke bare må slukke for en
Linux-maskine - den skal helst lukkes pænt ned.
</PARA>

<PARA>
Som vi viste i <xref linkend="runlevel">, er runlevel 0 det samme som
at lukke ned. En generel, men lidt besværlig måde at lukke en UNIX-maskine
på, er at skifte til root og skrive <userinput>init 0</userinput>
eller <userinput>telinit 0</userinput>
</para>

<SCREEN>
<PROMPT>[anne@linus ~]$ </PROMPT><USERINPUT>su -</USERINPUT>
Passwd: <USERINPUT>hemlig</USERINPUT>
<PROMPT>[root@linus /root]# init 0</PROMPT>
</SCREEN>

<indexterm><primary>Ctrl-Alt-Delete</primary></indexterm>

<para>
En hurtig nedlukning fås ved at trykke
"Ctrl-Alt-Delete", når du er i en tekstkonsol - f.eks. efter du
trykker "Ctrl-Alt-F1".
</para>

<para>
Du skal dog en gang for alle lave en ændring, så "Ctrl-Alt-Delete"
kommer til at medføre at Linux lukkes ned. Ændres intet, genstarter
systemet.  For at få maskinen til at stoppe
kaldes <command>/sbin/halt</command>, og skal du ændre i
<FILENAME>/etc/inittab</FILENAME>
</para>

<SCREEN>
# Trap CTRL-ALT-DELETE
ca::ctrlaltdel:/sbin/shutdown -t3 -r now
</SCREEN>

<para>
så der kommer til at stå
</para>

<SCREEN>
# Trap CTRL-ALT-DELETE
ca::ctrlaltdel:/sbin/shutdown -t3 -h now
</SCREEN>

<para>
Du kan selvfølgelig være fræk, så maskinen slet ikke kan stoppes fra
tastaturet med "Ctrl-Alt-Delete", f.eks. kan du
ændre <FILENAME>/etc/inittab</FILENAME> til
</para>

<SCREEN>
# Trap CTRL-ALT-DELETE
ca::ctrlaltdel:echo "No reboot for you my friend!\n"
</SCREEN>

<para>
Dette er uhyre praktisk, hvis din maskine står et sted, hvor der er
mange pilfingre, f.eks. edb-lokalet på en skole!
</PARA>
</sect1>

<sect1 id="crontab">
<title>Crontab</title>
<indexterm><primary>Cron</primary><secondary>crontab</secondary></indexterm>
<para>
Crontab er et smart system til automatisk at køre programmer på givne
tidspunkter, såsom daglig backup. Det er en standarddel af et
UNIX-system og er derfor altid med i Linux.
</para>

<para>
Man kan få kørt vilkårlige programmer på vilkårlige tidspunkter,
f.eks. hvert minut, hver time, hver dag, ugedag eller månedsdag.  I filen
<filename>/etc/crontab</filename> retter man normalt ikke, men denne
fil viser, at der køres jobs hver time fra
<filename>/etc/cron.hourly</filename> til tilsvarende hver dag, uge og
måned via <filename>/etc/cron.daily</filename>,
<filename>/etc/cron.monthly</filename> og
<filename>/etc/cron.weekly</filename>.  For en almindelig bruger er
det normalt, at man føjer de kommandoer man vil have kørt på et givet
tidspunkt, til filen <filename>~/.crontab</filename> og kører
kommandoen <command>crontab ~/.crontab</command>.
</para>

<para>
Syntaksen for alle disse crontab-filer er den samme: En kommando per linje
og i rækkefølge fra venstre mod højre, minut (0-59), time (0-23),
månedsdag (0-31), måned (0-12), ugedag (0-7, hvor 0 og 7 begge er søndag)
og endelig den kommando du vil have udført. Hvert felt adskilles af et
mellemrum, og hvis man vil have, at f.eks. alle dage køres
programmet, så indsæt en "*" for månedsdag og måned.</para>

<para> Vi giver nu et eksempel, hvor vi hver morgen kl. 7 fra mandag
til fredag sender brugeren "root" et brev med, hvor meget belastning 
der er på maskinen.
<screen>
0 7 * * 1-5 uptime | mail root
</screen>
Brug <command>man -a crontab</command> til at læse mere om
crontab. Skift til næste man-fil ved at trykke 'q'.
</para>
</sect1>





<SECT1 ID="sikkopi">
<!-- Skrevet af Claus Sørensen "cs@klid.dk" -->

<TITLE>Sikkerhedskopiering</TITLE>
<indexterm>
 <primary>Sikkerheds-kopiering</primary>
</indexterm>
<indexterm>
 <primary>Backup</primary>
</indexterm>

<para>
En vigtig del af systemadministration er sikkerhedskopiering, 
så man i tilfælde af nedbrud, harddiskcrash, brand 
eller andre uheld kan fortsætte uden større tab af data.
</para>

<para>
Sikring af ens data kan ske på flere måder, hvilket selvfølgelig er
afhængigt af den grad af sikkerhed man ønsker, samt mængden af data,
som skal sikres.
</para>

<SECT2 ID="sikkopi-metoder">
<TITLE>Metoder for sikkerhedskopiering</TITLE>
<para>
Grundlæggende kan man dele sikkerhedskopiering op i lokal- 
og fjernkopiering, hvilket bestemmes af det omfang af 
sikring som ønskes samt de tekniske muligheder som 
forelægger eller investering i samme.
</para>

<sect3 id="sikkopi-lokal">
<TITLE>Lokal sikkerhedskopiering</TITLE>

<para>
Lokal sikkerhedskopiering sker ved at man
gemmer kopier af sine data på samme sted, som dataerne
er på. Her benyttes oftest disketter, bånd, brændbare 
cdrommer eller udskiftelige harddiske som lagringsmedier.
</para>
</sect3>

<sect3 id="sikkopi-fjern">
<TITLE>Sikkerhedskopiering via Internettet</TITLE>

<para>
Fjernkopiering sker ved, at man aftaler med andre, 
at de krypteret spejler ens data samtidig med, at man 
gør det samme med deres. Det kræver selvfølgelig en 
tro på dem, som man udveksler data med, selvom dataene 
er krypterede.
</para>

<para>
Fjernkopiering er blevet mere aktuel efter at 
højhastighedsforbindelser (ADSL m.v.) er kommet ned i et 
prisleje, hvor også private og mindre virksomheder kan 
være med.
</para>

<para>
Man nøjes med at kopiere de forskelle, som er sket siden 
sidst, så man belaster forbindelsen mindst muligt. Hvis 
man ikke stoler blindt på den, som giver plads til ens 
sikkerhedskopi, kan man altid kryptere dataene med 
GnuPG eller lignende krypteringsværktøjer.
</para>
</sect3>

<sect3 id="sikkopi-hvad">
<TITLE>Hvad skal kopieres?</TITLE>


<para>
Generelt skal man gemme de data, som man ikke kan 
undvære, og som er umulige at fremskaffe på anden vis f.eks. 
via installation.
</para>

<para>
Dette kan være en af baggrundene for at dele et Linux-system op i
flere partitioner, da visse værktøjer netop sikkerhedskopierer efter
partitioner. De vigtigste kataloger er <filename>/home</filename>
(brugerdata), <filename>/var</filename> (serverdata) og
<filename>/etc</filename> (konfigurationsdata), som således også bør
have deres egne partitioner.
</para>

</sect3>



</SECT2>

<SECT2 ID="sikkopiprog">
<TITLE>Værktøjer til sikkerhedskopiering</TITLE>
<indexterm>
 <primary>Sikkerheds-kopiering</primary>
 <secondary>Værktøjer</secondary>
</indexterm>

<para>
Valget af værktøj til sikkerhedskopiering er afhængigt 
af en lang række faktorer så som lagringsmedie, 
type af adgang til systemet, graden af automation 
og omfanget af data.
</para>

<para>
I de næste afsnit vil forskellige værktøjer kort blive 
gennemgået, hvor deres fordele og ulemper vil blive 
belyst. Listen er på ingen måde udtømmende, men kan 
benyttes som et meget hurtigt overblik over de muligheder, 
som findes til sikkerhedskopiering i et Linux-miljø.
</para>

<sect3 id="sikkopi-tar">
<TITLE>Sikkerhedskopiering med tar</TITLE>
<indexterm>
 <primary>tar</primary>
</indexterm>
<indexterm>
 <primary>Sikkerheds-kopieringsværktøjer</primary>
 <secondary>tar</secondary>
</indexterm>
<para>
Den mest benyttede kommando til sikkerhedskopiering er 
<command>tar</command>, som er en forkortelse for Tape 
ARchive. <command>tar</command> samler blot filer og 
deres data sammen i en enkelt fil, som så kan gemmes 
på et medie til sikkerhedskopiering f.eks. et bånd.
</para>

<para>
Hvis du vil tage en sikkerhedskopi på disketter af 
alle filerne i kataloget <filename>/home</filename> 
gøres det således:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>tar -cMf /dev/fd0H1440 /home</userinput>
</screen>

<para>Hvor <command>-cMf</command> står for henholdsvis 
oprette (<command>c</command>reate), 
på flere medier (<command>m</command>ultiple) 
og viser hvilke filer (<command>f</command>iles).
</para>

<para> 
Når der ikke er mere plads på den første diskette, 
spørger programmet automatisk efter den næste.
</para>

<para>Hver gang man har foretaget en sikkerhedskopiering, 
skal man huske at kontrollere den, så man er sikker på, 
at man kan genskabe dataene fra sikkerhedskopien. Dette 
gøres således:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>tar -compare -verbose -f /dev/fd0H1440</userinput>
/home
/home/alle
/home/alle/annoncetekst.txt
....
</screen>

<para>
I stedet for de lange tilvalg kan benyttes de kortere
udgaver, hvilket kan ses af man-siden for 
<command>tar</command>.
</para>

<para>Skal man genskabe dataene igen, så er det ligetil:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>tar -extract -same-permissions -verbose -file /dev/fd0H1440</userinput>
/home
/home/alle
/home/alle/annoncetekst.txt
....
</screen>


<para>
Se mere ved hjælp af man-siden 
(<command>man tar</command>) eller i afsnittet om 
sikkerhedskopiering i 
"The Linux System Administrators' Guide":
<ulink url="http://www.linuxdoc.org/LDP/sag/index.html">http://www.linuxdoc.org/LDP/sag/index.html</ulink>. 
</para>

</sect3>

<sect3 id="sikkopi-dump">
<TITLE>Sikkerhedskopiering med dump og restore</TITLE>
<indexterm>
 <primary>dump</primary>
</indexterm>

<indexterm>
 <primary>restore</primary>
</indexterm>

<indexterm>
<primary>Sikkerheds-kopieringsværktøjer</primary>
 <secondary>dump</secondary>
</indexterm>

<indexterm>
<primary>Sikkerheds-kopieringsværktøjer</primary>
 <secondary>restore</secondary>
</indexterm>

<para>
Hvis man benytter Linux-filsystemet ext2, kan man 
benytte kommandoen <command>dump</command> til at 
gemme sikkerhedskopier helt eller delvist af hele 
filsystemet. De genskabes igen med kommandoen 
<command>restore</command>.
</para>

<para>
Som standard gemmer den kun de forskelle, som er 
opstået siden sidste sikkerhedskopiering, men den kan sættes 
til at tage en kopiering af det hele. 
</para>

<para>
Første gang man gemmer (samt med betryggende 
mellemrum) tages en sikkerhedskopi af alle filerne i 
en partition. Lad os sige at <filename>/home</filename> 
ligger på partition <filename>/dev/hda6</filename>, så 
ser det sådan ud:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>dump -u0 -f /dev/st0 /home</userinput>
</screen>

<para>
Genskabelsen af data sker ved, at man først genskaber 
filsystemet på den partition, som skal genskabes:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>mke2fs /dev/hda6</userinput>
<prompt>[root@linus /root]#</prompt> <userinput>mount /dev/hda6 /mnt</userinput>
<prompt>[root@linus /root]#</prompt> <userinput>cd /mnt</userinput>
</screen>

<para>
Så den bliver klar til at genskabe de data, som 
ligger i sikkerhedskopien:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>restore rf /dev/st0</userinput>
</screen>

<para>
Efter genskabelsen skal <filename>/home</filename> 
monteres igen:
</para>

<screen>
<prompt>[root@linus /root]#</prompt> <userinput>mount /mnt/home</userinput>
</screen>


<para>
Se mere om <command>dump</command> og 
<command>restore</command> ved at bruge deres 
man-sider.
</para>
</sect3>

<sect3 id="sikkopi-afio">
<TITLE>Sikkerhedskopiering med afio</TITLE>
<indexterm>
 <primary>Sikkerheds-kopieringsværktøjer</primary>
 <secondary>afio</secondary>
</indexterm>

<para>
Hvis man gerne vil have adgang til filerne individuelt 
efter sikkerhedskopieringen, kan man benytte værktøjet 
<command>afio</command>, som blandt andet bliver 
benyttet af KBackup.
</para>

<para>
Læs mere med <command>man afio</command>.
</para>

</sect3>

<sect3 id="sikkopi-kbackup">
<TITLE>Sikkerhedskopiering med KBackup</TITLE>
<indexterm>
 <primary>Sikkerheds-kopieringsværktøjer</primary>
 <secondary>KBackup</secondary>
</indexterm>

<para>
KBackup en alsidig applikation til håndtering af 
sikkerhedskopiering bygget oven på andre 
værktøjer blandt andet <command>tar</command> og 
<command>afio</command>.
</para>

<para>
Den menubaserede grænseflade er meget intuitiv 
at bruge, så man nemt får sat en god rutine op 
for sikkerhedskopiering af de data, man selv 
ønsker.
</para>

<para>
Flere informationer kan findes på KBackups 
hjemmeside: <ulink url="http://kbackup.sourceforge.net">http://kbackup.sourceforge.net</ulink>
</para>

</sect3>

<sect3 id="sikkopi-arkeia">
<TITLE>Sikkerhedskopiering med Arkeia</TITLE>
<indexterm>
 <primary>Sikkerheds-kopieringsværktøjer</primary>
 <secondary>Arkeia</secondary>
</indexterm>

<para>
Arkeia er et meget professionelt grafisk værktøj 
til håndtering af sikkerhedskopiering. Det er 
desværre closed sourced, men gratis også for 
virksomheder at bruge til en server og to klienter.
</para>

<para>
Hent vejledningen og programmet fra deres 
hjemmeside:
<ulink url="http://www.arkeia.com/">http://www.arkeia.com/</ulink>
og installér det.
</para>
</sect3>

<sect3 id="sikkopi-windows">
<TITLE>Microsoft Windows-værktøjer via Samba</TITLE>
<indexterm>
 <primary>Sikkerheds-kopieringsværktøjer</primary>
 <secondary>Til Microsoft Windows</secondary>
</indexterm>
<para>
Ligger ens data på en Samba-server, kan man i de fleste 
tilfælde bruge de Microsoft Windows-værktøjer, som 
følger med båndstation eller anden hardware til 
sikkerhedskopiering. Man skal så blot huske at oprette 
en sti til lagringsmediet i konfigurationsfilen til 
Samba (<filename>/etc/smb.conf</filename>).
</para>
</sect3>

</sect2>



</sect1>

<SECT1 ID="sysadm-afslutning">
<TITLE>Tips og tricks</TITLE>

<PARA>
Der er meget mere i systemadministration, end dette korte kapitel har
præsenteret. Til Linux findes der især to dokumenter, som er gode at
læse, nemlig "System Administrator's Guide" (SAG) og "Network
Administrator's Guide" (NAG) - begge kan hentes fra 
<ulink url="http://sunsite.dk/ldp">http://sunsite.dk/ldp</ulink> og
findes på din Red Hat cdrom. De er en del af "Linux
Documentation Project" (LDP). Red Hat's hjemmeside indeholder endvidere
en række gode tricks og nyttige oplysninger. De bedste bøger om UNIX
systemadministration er uden tvivl Æleen Frisch's "Essential System
Administration" udgivet af O'Reilly, og "UNIX System Administration
Handbook" (Evi Nemeth, Garth Snyder, Scott Seebass og Trent R. Hein) udgivet
af Prentice Hall PTR.
</PARA>

<para>
Vil du vide mere om sikkerhedskopiering 
under Linux, så kig i 
"The Linux System Administrators' Guide":
<ulink url="http://www.linuxdoc.org/LDP/sag/index.html">http://www.linuxdoc.org/LDP/sag/index.html</ulink>. 
</para>


</SECT1>
</chapter>
