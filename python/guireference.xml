<chapter id="python-windows">
<title>Vinduer, knapper og meget mere</title>

<para>
GUI komponenter skal stilles på plads i en container. Hvordan det gøres,
vil vi se på nu:
</para>

<para>
Tkinter modulet (Tk interfacet) er standard bindeledet mellem dit
program og Tk GUI biblioteket. Tkinter modulet omfatter selv et større
antal moduler. Tk interfacet (Tkinter) er kompileret til det binære
modul _tkinter, der omfatter et lavniveau interface til Tk, som du
aldrig bør bruge direkte. Sædvanligvis er det et delt bibliotek,
men kan i nogle tilfælde ønskes benyttet statisk (integreres i
programmet).
</para>

<para>
Ud over at være bindeled (interface) mellem dit program og Tk
biblioteket omfatter Tkinter et antal Python moduler, hvoraf de to
vigtigste er selve Tkinter og et modul kaldet Tkconstants. Sidstnævnte
ser vi normalt ikke meget til, så lad os lige se, hvad det indeholder:

<screen>
<prompt>>>></prompt> <userinput>import Tkconstants</userinput>
<prompt>>>></prompt> <userinput>dir(Tkconstants)</userinput>
<prompt>
['ACTIVE', 'ALL', 'ANCHOR', 'ARC', 'BASELINE', 'BEVEL', 'BOTH', 'BOTTOM', 'BROWSE', 'BUTT', 'CASCADE', 'CENTER', 'CHAR', 'CHECKBUTTON', 'CHORD', 'COMMAND', 'CURRENT', 'DISABLED', 'E', 'END', 'EW', 'EXTENDED', 'FALSE', 'FIRST', 'FLAT', 'GROOVE', 'HIDDEN', 'HORIZONTAL', 'INSERT', 'INSIDE', 'LAST', 'LEFT', 'MITER', 'MOVETO', 'MULTIPLE', 'N', 'NE', 'NO', 'NONE', 'NORMAL', 'NS', 'NSEW', 'NUMERIC', 'NW', 'OFF', 'ON', 'OUTSIDE', 'PAGES', 'PIESLICE', 'PROJECTING', 'RADIOBUTTON', 'RAISED', 'RIDGE', 'RIGHT', 'ROUND', 'S', 'SCROLL', 'SE', 'SEL', 'SEL_FIRST', 'SEL_LAST', 'SEPARATOR', 'SINGLE', 'SOLID', 'SUNKEN', 'SW', 'TOP', 'TRUE', 'UNITS', 'VERTICAL', 'W', 'WORD', 'X', 'Y', 'YES', '__builtins__', '__doc__', '__file__', '__name__']</prompt>
<prompt>>>></prompt>
</screen>
</para>

<para>
At vi normalt ikke ser noget til Tkconstants skyldes, at Tkinter
automatisk importerer modulet. Det eneste vi skal gøre er at køre
import Tkinter eller oftere from Tkinter import *
</para>

<para>Som tidligere nævnt er mainloop i konstant aktivitet, sådan er det
i Python og andre GUI applikationsmiljøer. Men ikke nok med det Tkinter
kan udstyre dit program med den mulighed, at du også selv kan aktive
hændelser (events). For hver enkelt kan du sammenbinde funktioner og
metoder med hændelserne:

<screen>
<userinput>widget.bind(event, handler)</userinput>
</screen>
</para>

<para>
Her er et eksempel, der kan uddybe, hvad det er, der sker når du klikker
(udsender events) ved at klikke med musen i et vindue (teksten udskrives
med print og hermed i skal shell).I eksemplet bruges frames bind metode
til at binde en såkaldt callback funktion til hændelsen fra
&lt;Button-&gt;> (venstre museknap). Ordet callback er ikke så helt
ueffen, for hvad er det, der sker, når der indtræder en hændelse? Jo,
handle sender en melding tilbage til programmet, at der er indtrådt en
hændelse f. eks. at der er blevet ændret størrelse på et vindue, eller
klikket på en knap.Men nu til eksemplet:

<programlisting>
from Tkinter import *
root = Tk()

def callback(event):
    print "Du klikkede på position", event.x, event.y

frame = Frame(root, width=200, height=200)
frame.bind("&lt;Button-1&gt;", callback)
frame.pack()

root.mainloop()
</programlisting>
</para>

<para>
I eksemplet brugte jeg navnet callback på metode og kald, da callback
er et ofte benyttet funktionsnavn i Python miljøet. Som antydet ovenfor
kunne callback fuldstændig lige så godt hedde f.eks. Metode eller et
hvilket som helst andet lovligt navn, så du kan også udmærket bruge.
&lt;Button-1&gt; kan langt hen ad vejen sidestilles med et ganske
almindeligt funktions- eller metodekald.

<screen>
<userinput>from Tkinter import *</userinput>

<userinput>root = Tk()</userinput>

<userinput>def Metode(event):</userinput>
    <userinput>print "Du klikkede på position", event.x, event.y</userinput>

<userinput>frame = Frame(root, width=200, height=200)</userinput>
<userinput>frame.bind("&lt;Button-1&gt;", Metode)</userinput>
<userinput>frame.pack()</userinput>
<userinput>root.mainloop()</userinput>
</screen>
</para>

<para>
Hvis du ændret &lt;Button-1&gt; til &lt;Button-2&gt;, er det musens
midterste tast, der aktiverer hændelserne. &lt;Button-3&gt; aktiverer
hændelser fra højre museknap.
</para>

<para>
Skriv nu følgende i en ganske almindelig teksteditor:

<screen>
<userinput>from Tkinter import *</userinput>
<userinput>root = Tk()</userinput>
<userinput>bindeled = Label(root, text="Containertekst")</userinput>
<userinput>bindeled.pack()</userinput>
<userinput>root.mainloop()</userinput>
</screen>
</para>

<para>
Gem eksemplet som eks1.py. Skift til det bibliotek, hvori eks1.py er
gemt, tast derfra:

<screen>
<prompt>tyge@hven ~</prompt><userinput>python eks1.py</userinput>
</screen>
</para>

<para>
<figure float="1"><title>Titel</title><graphic fileref="tk1.&magic;" scale="40"></graphic></figure>
</para>

<para>
Programafviklingen stopper, når du lukker vinduet.
</para>

<para>
Hvad var det dog, der skete?
</para>

<para>
Vi begyndte med at importere Tkinter modulet. Det indeholder alle
klasser, funktioner, konstante og andre ting, der er nødvendige for
kommunikationen med Tk biblioteket (kaldes undertiden the Tk toolkit).
I de fleste tilfælde kan du ganske enkelt importere alt fra Tkinter:

<screen>
<userinput>from Tkinter import *</userinput>
</screen>
</para>

<para>
Vi ville have opnået samme resultat (samme vindue med indhold med:

<screen>
<prompt>>>></prompt> <userinput>from Tkinter import Label</userinput>
<prompt>>>></prompt> <userinput>Label(text="Containertekst").pack()</userinput>
<prompt>>>></prompt>
</screen>
</para>

<para>
Her nøjes vi med at importere det modul, der reelt er brug for lige her
og nu, men som regel er der brug for mere, så  vi fortsætter med at se
videre på det første eksempel ovenfor.
</para>

<para>
For at initialisere Tkinter (tildele Tkinter opstartsværdier) oprettede
vi en Tk rod widget. Et typisk GUI bibliotek (toolkit) omfatter et antal
brugsklare GUI byggeklodser sædvanligvis kaldet widgets. Almindeligt
forekommende widgets omfatter tekst og image labels, knapper m.v. Dem
ser vi eksempler på senere.
</para>

<para>
Det fra Tk biblioteket importerede rodmodul er en sådan widget. Det
indeholder et ganske almindeligt, fuld færdigt vindue med hvad dertil
hører
</para>

<para>
root = Tk() alene opretter og viser vinduet med dets egne bestanddele -
et tomt vindue. Et sådant er der normalt ikke det store brug for, der
skal andre objekter i det. Tk root widget er altså container for
programmets øvrige elementer, hvorfor root skal oprettes før alt andet.
Det nævnte trin er nu at integrere andre byggeklodser i programmet. I
vort eksempel nøjes vi med en Label widget. Den skal anbringes i root
widgetten. Indledningsvis oprettede vi indterface mellem Tk biblioteket
og vores program. Nu har vi brug for endnu et interface - det der skal
danne kontakten mellem selve vinduet og det, der placeres på det. Denne
kontakt oprettes her med:

<screen>
<userinput>bindeled = Label(root)</userinput>
</screen>

For at være bindeled mellem Label modulets indhold og det øvrige program
må bindeled omfatte en hel del kode, der nødvendigvis må komme et eller
andet sted udefra, hvilket i det aktuelle tilfælde nødvendigvis vil sige
fra Label selv. Hvis du har en ganske almindelig numerisk variabel a,
kan du oprette en anden b med:

<screen>
<prompt>>>></prompt> <userinput>a = 25 </userinput>
<prompt>>>></prompt> <userinput>b = a </userinput>
<prompt>>>></prompt> <userinput>b</userinput>
<userinput>25 </userinput>
<prompt>>>></prompt>
</screen>

b er herved blevet en kopi af a - b har med andre ord arvet a variablens
indhold. Det er et tilsvarende arveforhold vi finder i følgende:

<screen>
<prompt>>>></prompt> <userinput>from Tkinter import Label</userinput>
<prompt>>>></prompt> <userinput>bindeled = Label()</userinput>
</screen>

At bindeled virkelig har arvet Label og dermed altså er Labels kopi,
arving eller barn fremgår af følgende:

<screen>
<prompt>>>></prompt> <userinput>bindeled</userinput>
<userinput>&lt;Tkinter.Label instance at 0x81b6bec&gt;</userinput>
<prompt>>>></prompt>
</screen>
</para>

<para>
Hvad arven omfatter kan undersøges med følgende eksempel:

<screen>
<prompt>>>></prompt> <userinput>from Tkinter import Label</userinput>
<prompt>>>></prompt> <userinput>bindeled = Label()</userinput>
<prompt>>>></prompt> <userinput>dir(bindeled)</userinput>

<userinput>['__class__', '__delattr__', '__doc__', '__getattribute__', '__hash__', '__init__', '__new__', '__reduce__', '__repr__', '__setattr__', '__str__']</userinput>
<prompt>>>></prompt>
</screen>
</para>

<para>
Her foregår arven:

<screen>
<prompt>>>></prompt> <userinput>from Tkinter import Label</userinput>
<prompt>>>></prompt> <userinput>bindeled = Label(text = "bindeled arver mig")</userinput>
</screen>

men kører du eksemplet, vil du opdage, at teksten "bindeled arver
mig" ikke udskrives - bindeled er ejer af et antal ting, men har ikke
fået at vide, hvor disse ting kan placeres. Den besked tilføres med
pack() funktionen, men det kan ske på et par forskellige måder:

<screen>
<prompt>>>></prompt> <userinput>from Tkinter import Label</userinput>
<prompt>>>></prompt> <userinput>bindeled = Label(text = "bindeled arver mig")</userinput>
<prompt>>>></prompt> <userinput>bindeled.pack()</userinput>
</screen>

eller:

<screen>
<prompt>>>></prompt> <userinput>from Tkinter import Label</userinput>
<prompt>>>></prompt> <userinput>bindeled = Label(text = "bindeled arver mig").pack()</userinput>
</screen>

<screen>
<prompt>>>></prompt> <userinput>from Tkinter import Label</userinput>
<prompt>>>></prompt> <userinput>bindeled = Label(text = "Jeg kan indeholde tekst og ikoner.").pack()</userinput>
<prompt>>>></prompt>
</screen>
</para>

<para>
Vender vi nu tilbage til det indledende eksempel, finder vi kun 1
programlinje, vi ikke har set i funktion:

<programlisting>
from Tkinter import *
root = Tk()
bindeled = Label(root, text="Containertekst")
bindeled.pack()
root.mainloop()
</programlisting>
</para>

<para>
mainloop() metoden kaldes undertiden for hændelsesløkken Det gør den,
fordi den er en ikke, der holder kontrol med, om der indtræder en
eller anden hændelse (event). Når den er startet op løber den i ring
indtil vinduet lukkes.  Hændelserne kan være brugers klik på en
musetast, tryk på en tast eller hvad nu brugeren kan finde på at
foretage i og med programmet, men de holder også styr på hvad der sker
fra programmets side f.eks. i forbindelse med at brugeren klikker på en
af knapperne i vinduets øverste højre hjørne ligesom løkken også holder
styr, på hvad der sker i selve Tkinter, hvordan Tkinter holder styr på
brugen af de mange metoder, klasser m.v., der er i Tk biblioteket.
</para>

<para>
Skriver du større programmer, er det sædvanligvis en god idé at dele dem
op i et antal klasser. Hvordan det kan gøres, vil vi se på nu.
</para>

<para>
Defineringen af en klasse indledes med nøgleordet class efterfulgt af et
lovligt navn og et kolon. Klassen kan have en parameterliste eller som
her være uden en sådan. Er der en parameterliste, kan den ikke være tom.

I næste programlinje sker initialiseringen (den grundlæggende
værditildeling). Denne linje kaldes også konstruktøren  Den skal altid
have en parameterliste, der som her kan være tom, men vil normalt
indeholde et argument med klassens navn eller oftere et self, der
repræsenterer klassenavnet. Klassekonstruktøren skal afsluttes med et
kolon.

<screen>
<prompt>>>></prompt> <userinput>class Klasse:</userinput>
	<userinput>def _init_():</userinput>
		<userinput>pass</userinput>
</screen>

pass er beregnet til at gøre ingenting. Her bruges pass til at komme
rigtigt ud af programmet. I klassen anbringes alle de komponenter, der
skal bruges  i programmet.
</para>

<para>
<screen>
<prompt>>>></prompt> <userinput>from Tkinter import *</userinput>
<prompt>>>></prompt> <userinput>class Klasse:</userinput>
	<userinput>def _init_(Klasse):</userinput>
		<userinput>pass</userinput>

<prompt>>>></prompt> <userinput>Klasse</userinput>
<prompt>&lt;class __main__.Klasse at 0x82c680c&gt;</prompt>
<prompt>>>></prompt>
</screen>
</para>

<para>
Argumentet i _init_ metoden skrives normalt ikke som selve klassenavnet.
Den normale måde at skrive det samme eksempel på er:

<screen>
<prompt>>>></prompt> <userinput>from Tkinter import *</userinput>
<prompt>>>></prompt> <userinput>class Klasse:</userinput>
	<userinput>def _init_(self):</userinput>
		<userinput>pass</userinput>

<prompt>>>></prompt> <userinput>Klasse</userinput>
<prompt>&lt;class __main__.Klasse at 0x8263884&gt;</prompt>
<prompt>>>></prompt>
</screen>

class viser, at Klasse er en klasse. En sådan eller rettere kroppen i en
klasse er en namespace (en plads for navne som f.eks. variabler og
funktioner).
</para>

<para>
Helt på tilsvarende måde som vi har set, Label kan bruges, kan Frame og
en masse andre komponenter anvendes:

<screen>
<prompt>>>></prompt> <userinput>from Tkinter import *</userinput>
<prompt>>>></prompt> <userinput>Frame().pack()</userinput>
<prompt>>>></prompt>
</screen>
</para>

<para>
Det er normalt Frame komponenten, der bruges som container. Derfor skal
Frame oprettes som første komponent. Der skal jo være et komponent til
at anbringe de øvrige GUI objekter i.

<screen>
<prompt>>>></prompt> <userinput>from Tkinter import *</userinput>
<prompt>>>></prompt> <userinput>class Klasse:</userinput>
	<userinput>def __init__(self):</userinput>
		<userinput>frame = Frame(self)</userinput>
            	<userinput>frame.pack()</userinput>
<prompt>>>></prompt> <userinput>Klasse() # klassekald</userinput>
</screen>
</para>

<para>
Som vi allerede har set på er det vigtigt at forstå at self er et
synonym for navnet Klasse. Det er ikke bare her, men generelt, at det
forholder sig således. 

<screen>
<prompt>>>></prompt> <userinput>from Tkinter import *</userinput>
<prompt>>>></prompt> <userinput>class Klasse(Frame):</userinput>
	<userinput>def _init_(self):</userinput>
		<userinput>frame = Frame(self).pack(expand = YES, fill = both)</userinput>
<prompt>>>></prompt> <userinput>Klasse()  # bevirker at vinduet vises.</userinput>
</screen>
</para>

<para>
I pack() metoden, kan der indsættes parametre for retten til at måtte
udvide komponenten, hvor komponenten skal placeres og hvor lang og bred
komponenten skal være Som her frame = Frame er det en god skik at give
barnet (the child) samme navn som moderen (the parent) blot skrevet med
lille begyndelsesbogstav. Når jeg ikke har valgt at følge denne regel i
denne bog er det alene for at åbne læserens øjne for, hvad det er, der
reelt foregår og for at man ofte med fordel kan bruge danske navne. Hvad
jeg konkret mener, vil jeg godt vise ved at udvide ovenstående eksempel
med en knap. Da eksemplet herved bliver noget større, vil jeg gemme det
som Tk1.py - kørslen sker jo så ved at du fra det aktuelle bibliotek,
hvori filen er gemt skriver python Tk1.py og trykker på Enter-tasten.
Ved skriveriet er der behov for at vende tilbage til root, for vi har
brug for mainloop() metoden. Den kan ikke kaldes direkte fra Klasse, da
root ikke er argument i Klassen (findes ikke i roots parameterliste).

<programlisting>
from Tkinter import *
root = Tk()
class Klasse:
	def _init_(Klasse):
		frame = Frame(Klasse).pack(expand = YES, fill = both)

  		Klasse.knap = Button(frame).pack()

root.mainloop()
</programlisting>
</para>

<para>
Det helt samme eksempel i den normal sete version med self og med
moderens navn skrevet med lille begyndelsesbogstav:

<programlisting>
from Tkinter import *
root = Tk()
class Klasse:
	def _init_(self):
		frame = Frame(self).pack(expand = YES, fill = both)

  		self.button = Button(frame).pack()

root.mainloop()
</programlisting>
</para>

<para>
At knappen tilhører Klasse får fortolkeren at vide med self.button. Til
konstruktion af knappen benyttes den i Python fordefinerede kode, der
findes i Button objektet. Knappen skal ikke være frit svævende, men skal
placeres et eller andet sted i frame. For at kunne gøre det kræves der
1: interface. Det dannes med Button(frame) og 2: den velkendte pack()
metode, der placerer knappen på den rette plads i Frame objektet. Fordi
man kan ønske at stille tingene på plads på flere objekter objekt for
objekt, kan pack() skulle bruges 2 gange i forbindelse med det enkelte
objekt. Grundmodellen hertil kan se nogenlunde således ud:

<screen>
<userinput>from Tkinter import *
root = Tk()
class Klasse:
	def _init_(self):
		frame = Frame(self).pack(expand = YES, fill = BOTH)

  		self.button = Button(frame).pack()

root.mainloop()</userinput>
</screen>
</para>

<para>
Du kan så vælge at flytte pakkefunktionen ned på dens egne programlinje
som her:

<screen>
<userinput>from Tkinter import *
root = Tk()
class Klasse:
	def _init_(self):
		frame = Frame(self).pack(expand = YES, fill = BOTH)

  		self.barn = Button(frame)
		self.barn().pack(side = TOP)
root.mainloop()</userinput>
</screen>
</para>

<para>
frame har arvet egenskaben  at kunne udvides  og egenskaben at kunne
lade udvidelsen ske i begge retninger - både vandret og lodret.
Egenskaberne tilføres med pack metoden.  expand = YES betyder, at det
objekt, der har fået egenskaben, kan lade sig udvide, men ikke at
objektet skal udvides. I enkelte tilfælde kan man se YES erstattet med
tallet 1. expand kan også tildeles værdien NO altså expand = NO eller
tilsvarende expand = 0. fill kan også tildeles værdien NONE (den er
forvalgt). side = TOP har ikke den store relevans i eksemplet ovenfor
dels fordi side er forvalgt til TOP, men også og især fordi der kun er
et objekt (den ene knap) placeret i frame. Havde der været flere, var de
ved brug af side = TOP blevet placeret lodret under hinanden. Jeg har
taget det med for at få lejlighed til at forklare, at side kan tildeles
værdierne TOP, RIGHT og LEFT.
</para>

<para>
I det følgende eksempel, der viser samtlige egenskaber er knap er i
besiddelse af, vil vi begynde beskrivelsen bagfra med root.mainloop().
Den er nødvendig for at få knappen vist og gjort aktiveringsklar.
root = Tk() er nødvendig for at gøre root kendt i programmet og dermed
gøre mainloop køreklar Dens funktion er som beskrevet tidligere at
opfange interne og eksterne hændelser (events). Pakkefunktionens kender
du fra det allerede nævnte. command  kalder metoden Metode. bg står for
baggrundsfarve og fg for forgrundsfarve (her for tekstfarven), text
repræsenterer teksten på knappen, name er knappens navn. I større
programmer kan der være henvist til knappen ligesom der tilsvarende kan
henvises til andre objekter i programmet, da er der brug for navnet,
hvad der ikke er i eksemplet her, det kunne udmærket udelades her. Det
samme kunne farverne.

<programlisting>
from Tkinter import *
root = Tk()

def Metode():
	print "Hvem kalder?" # skriver i skal (shell)

Button(root, name = "knappensNavn", text = "Klik her", fg = "red",bg = "white", command = Metode).pack(expand = 1, fill = BOTH)
root.mainloop()
</programlisting>
</para>

<para>
Da pladsen i bogen er relativ knap, vil vi slutte af med knappen lige nu
ved at integrere de to sidst viste eksempler i hinanden  (jeg viser også
et par helt nye ting i eksemplet) og bemærke, at noget der kan sættes
sammen ofte også kan skilles ad. Det kan vi bruge til noget i
forbindelse med større programeksempler. Sidder du med sådanne og måske
ikke har fuldt overblik over, hvordan en delkode virker, så pil den ud
og skriv et kort eksempel i interaktiv mode.

<screen>
<userinput>from Tkinter import *
root = Tk()

def Metode():</userinput>
</screen>

mode, hvori delkoden f.eks., som her en knap indgår. 

<screen>
<userinput>from Tkinter import *
win 	print "Sender hilsen til dig."
class KnapDemo( Frame ):
	def __init__( self ):
		Frame.__init__( self )
      		self.pack( expand = YES, fill = BOTH )
      		self.master.title( "Knap demo" )

  		self.knap = Button(win, name = "knappensNavn", text = "Klik her", fg = "red",bg = "white", command = Metode)
		self.knap.pack( side = LEFT, padx = 5, pady = 5 )

def main():
	KnapDemo().mainloop()

if __name__ == "__main__":
	main()</userinput>
</screen>
</para>

<para>
Som afslutning på knapper i denne omgang skal vi se på et større
eksempel:

<programlisting>
from Tkinter import *
from tkMessageBox import *

class KnapDemo(Frame):
   def __init__( self ):
	Frame.__init__( self )
      	self.pack( expand = YES, fill = BOTH )
      	self.master.title( "Knap demo" )

      	self.tekstknap = Button( self, text = "Tekstknap",
         command = self.TekstKlikket )
      	self.tekstknap.bind( "&lt;Enter&gt;", self.rolloverEnter )
      	self.tekstknap.bind( "&lt;Leave&gt;", self.rolloverLeave )
      	self.tekstknap.pack( side = LEFT, padx = 5, pady = 5 )

      	self.ikon = PhotoImage( file = "tkx.gif" )
      	self.grafikknap = Button( self, image = self.ikon,
         command = self.IkonKlikket )

      	self.grafikknap.bind( "&lt;Enter&gt;", self.rolloverEnter )
      	self.grafikknap.bind( "&lt;Leave&gt;", self.rolloverLeave )
      	self.grafikknap.pack( side = LEFT, padx = 5, pady = 5 )

   def TekstKlikket( self ):
      showinfo( "Melding", "Du aktiverede Tekstknap" )

   def IkonKlikket( self ):
      showinfo( "Melding", "Du aktiverede Grafik knap" )

   def rolloverEnter( self, event ):
      event.widget.config( relief = GROOVE )

   def rolloverLeave( self, event ):
      event.widget.config( relief = RAISED )

if __name__ == "__main__": KnapDemo().mainloop()
</programlisting>
</para>

<para>
Her er det vist kun nødvendigt at se på relief = GROOVE og relief =
RAISED, da det øvrige må være velkendt for dig nu. relief indstillingen
har til formål at tegne kanten omkring objektet, her omkring knappen.
De fleste widgets har en forvalgt kantbredde (borderwidth eller
forkortelsen bd) på 1 eller 2 pixels. Der er sjældent brug for at ændre
denne indstilling, selv om det er ganske enkelt. Derimod kan det være
nyttigt at anvende relief, der tegner den 3-dimensionale kant (border).
relief kan tildeles en af værdierne SUNKEN, RAISED, GROOVE, RIDGE eller
FLAT.

   <figure float="1">
    <title>Titel</title>
    <graphic fileref="Tkknap.&magic;" scale="40"></graphic>
   </figure>
</para>

 <sect1 id="python-gui-events">
  <title>Hændelser (events)</title>

<para>
Hændelse &lt;Button-1&gt;
</para>

<para>Beskrivelse:</para>

<para>
En museknap  blev aktiveret over et widget. Knap 1 er venstre museknap,
2 den midterste og 3 den højre knap. Når en museknap aktiveres over en
widget vil mainloop sende en melding om det til Tkinter, der vil "fange"
meldingen og køre den kommando f.eks. afvikle en metode indtil den
via museknappen igangsatte aktivitet afsluttes efter veludført arbejde
&lt;Button-1&gt;, &lt;ButtonPress-1&gt; og &lt;1&gt; er synonymer for
det samme - klik på venstre museknap ligesom &lt;Button-2&gt;,
&lt;ButtonPress-2&gt; og &lt;2&gt; er det for midterste museknap og
&lt;Button-3&gt;, &lt;ButtonPress-3&gt; og &lt;3&gt; for højre. Hvilken
af de givne muligheder du vælger er op til dig.
</para>

<para>Hændelse &lt;B1-Motion&gt;</para>

<para>Beskrivelse:</para>

<para>
Musen blev flyttet over en widget, mens venstre museknap (knap 1) blev
holdt nede. Tilsvarende for midtertasten er &lt;B2-Motion&gt; og for
højre musetast &lt;B3-Motion&gt;
</para>

<para>Hændelse &lt;ButtonRelease-1&gt;</para>
<para>Beskrivelse:</para>

<para>
Venstre museknap blev sluppet, mens den var over den valgte widget.
Tilsvarende for midtertasten er &lt;ButtonRelease-2&gt; og for højre
musetast %lt;ButtonRelease-3&gt;
</para>

<para>Hændelse &lt;Double-Button-1&gt;</para>

<para>Beskrivelse:</para>

<para>
I Python kan du bruge såvel enkelt som dobbelt (double) og tre gange
(triple) klik i Hændelser. &lt;Double-Button-1&gt; betyder dobbeltklik
på venstre museknap og &lt;Triple-Button-1&gt; betyder klik 3 gange
efter hinanden på samme musetast og på samme objekt. Som ved en gang
klik på museknap kan også &lt;Double-Button-2&gt; og
&lt;Triple-Button-2&gt; og &lt;Double-Button-3&gt; og
&lt;Triple-Button-3&gt; benyttes her. Bemærk at såfremt du bind til både
enkelt og dobbeltklik, så kan begge bindinger kaldes. Hvordan en binding
foretages er vist tidligere i afsnittet om Hændelser.
</para>

<para>Hændelse &lt;Enter&gt;</para>
<para>Beskrivelse:</para>

<para>
Musemarkøren kom ind i widgets område (Bemærk hændelsen må ikke
forveksles med tryk på Enter tasten). Modsvarer &lt;Leave&gt;
</para>

<para>Hændelse &lt;Leave&gt;</para>
<para>Beskrivelse:</para>

<para>
Musemarkøren forlod widgets område Modsvarer &lt;Enter&gt;
</para>

<para>Hændelse &lt;Return&gt;</para>

<para>Beskrivelse:</para>

<para>
Brugeren trykkede på Enter (Return) tasten. Du kan binde (bind) til
stort set alle tastaturets taster. På det almindelige 102-tasters PC
tastatur kan du således også bruge Cancel (Break tasten), BackSpace,
Tab, Return, Shift_L (enhver Shift tast forbindelse), Control_L (enhver
Control tast forbindelse), Alt_L (enhver Alt tast kombination), Pause,
Caps_Lock, Escape, Forrige (Page Up), Nste (Page Down), End, Home,
Left, Up, Right, Down, Print, Insert, Delete, F1, F2, F3, F4, F5, F6,
F7, F8, F9, F10, F11, F12, Num_Lock og Scroll_Lock.
</para>

<para>Hændelse  &lt;Key&gt;</para>

<para>Beskrivelse:</para>

<para>
Brugeren trykkede på tast &lt;Key&gt;.
</para>

<para>Hændelse  a</para>

<para>Beskrivelse:</para>

<para>
Brugeren trykkede på a tasten. De fleste printbare tegn kan
anvendes tilsvarende - undtagelser er mellemrumstasten (den største tast p
tastaturet) og mindre end "&gt;". Bemærk at 1 betyder binding til 1-tallet
på tastaturet, mens &lt;1&gt; er binding til venstre museknap.
</para>

<para>Hændelse &lt;Shift-Up&gt;</para>

<para>Beskrivelse:</para>

<para>
Brugeren trykkede på Pil op tasten, samtidig med at Shift tasten blev
holdt nede. På samme måde kan Alt og Control tasterne anvendes.
</para>

<para>Hændelse &lt;Configure&gt;</para>

<para>Beskrivelse:</para>

<para>
Det aktuelle widget ændrede størrelse (p nogle platforme beliggenhed).
Widgets højde og bredde overføres til Tkinter ved hjælp af callback.
</para>

<sect2 id="python-mouse-events">
<title>Musen i vinduet</title>

<para>
Da der er en del bindinger i det kommende afsnit om Widget klassen, vil
vi slutte af her med et eksempel med musen og med bindinger mellem
vindue og museknapper. Jeg kommer meget mere ind på musen og hvad dertil
hører i det nævnte afsnit, så her vil jeg lade eksemplet stå nogenlunde
alene og kommentere senere. Men lad os lige se på en enkelt programlinje:

<screen>
<userinput>
self.bind( "&lt;Button-1&gt;", self.knapAktiveret )
</userinput>
</screen>
</para>

<para>
I stedet for at det er en ganske almindelig funktion, der kalder
(afvikler) den funktion, der er bundet til klassen med
self.knapAktiveret, skal der her bruges en fordefineret klasse
indeholdende en lang række metoder, så der kan vises den virtuelle knap,
du skal klikke på med venstre museknap, at det er venstre museknap, du
skal bruge her fremgår af 1-tallet i "Button-1". Større end mindre end
tegnene viser, at det er en museknap. Havde de ikke været med, så der
alene stod "Button-1" var det en af knapperne på tastaturet, der skulle
bruges. Metoden mainloop() skal køre hele tiden, mens programmet
benyttes for blandt rigtig meget andet at kontrollere, om du klikker p
"&lt;Button-1&gt;" eller en af de andre knapper, om brugeren flytter
musen med venstre knap nedtrykket (sker med "&lt;B1-Motion&gt;") eller
en af de mange andre ting en af de mange mange andre ting, bruger,
computer, system eller program kan foretage. Klikker bruger på en tast,
sender mainloop() besked til værkføreren Tkinter, der dels finder ud af,
hvad der skal foretages og hvilke metoder m.v. der skal bruges for at
udføre den kommando, der udgik via klikket på knappen. Sådan er det i
Python og andre andre computersprog og styresystemer med grafisk
brugerflade.

<programlisting>
from Tkinter import *

class Musepositioner( Frame ):
   def __init__( self ):
      Frame.__init__( self )
      self.pack( expand = YES, fill = BOTH )
      # rammens titel
      self.master.title( "Demonstrerer musehændelser og bindinger" )

      # Vinduet tegnes 275 pixels bredt og 200 pixels højt
      self.master.geometry(  "275x200" )
      self.musePosition = StringVar()
      self.musePosition.set( "Mus udenfor vinduet" )
      self.positionLabel = Label( self, textvariable = self.musePosition )
      self.positionLabel.pack( side = BOTTOM )

      # bind musehændelser fra venstre museknap til vindue
      self.bind( "&lt;Button-1&gt;", self.knapAktiveret )
      self.bind( "&lt;ButtonRelease-1&gt;", self.knapSluppet )
      self.bind( "&lt;Enter&gt;", self.inde_i_vinduet )
      self.bind( "&lt;Leave&gt;", self.ude_af_vinduet )
      self.bind( "&lt;B1-Motion&gt;", self.mouseDragged )

   def knapAktiveret( self, event ):
      # event.x og event.y er koordinaterne altså heltal derfor konverteres de til streng
      self.musePosition.set( "Du klikkede på position [ " + str( event.x ) +
         ", " + str( event.y ) + " ]" )

   def knapSluppet( self, event ):
      self.musePosition.set( "Museknap sluppet på position [ " + str( event.x ) +
         ", " + str( event.y ) + " ]" )

   def inde_i_vinduet( self, event ):
      self.musePosition.set( "Musen er i vinduet" )

   def ude_af_vinduet( self, event ):
      self.musePosition.set( "Musen er udenfor vinduet" )

   def mouseDragged( self, event ):
      self.musePosition.set( "Musetræk på [ " + str( event.x ) +
         ", " + str( event.y ) + " ]" )

def main():
   Musepositioner().mainloop()

if __name__ == "__main__":
   main()
</programlisting>
</para>
</sect2>

<sect2 id="python-widget-class">
<title>Widget klassen</title>

<para>
Et grafisk bruger interface (grafical user interface heraf forkortelsen
GUI) giver brugeren mulighed for at kommunikere interaktivt med et
program. Grafiskebrugergrænseflader sammensættes af GUI komponenter (kaldet widgets - en
forkortelse for windows finesser). Et GUI komponent er et objekt hvormed
en bruger som antydet kan kommunikere interaktivt med et program via mus
og eller tastatur. Ved brug af Tool Command Language (forkortet TCL) og
dets værktøjskasse (Tool Kit forkortet Tk - et bibliotek af fordefinerede
klasser, subklasser m.v.) kan Python programmører konstruere grafiske brugergrænseflader.
Hvordan det gøres skal vi se på i en lang række eksempler.
</para>

<para>Almindeligt forekommende egenskaber for widgets er:</para>

<para>activebackground og activeforeground.</para>

<para>De farver der bruges, når knappen aktiveres.</para>

<para>ANCHOR (eller anchor)</para>
<para>Markerer starten på det valgte, hvis der et sådant. Kontrollerer
hvor på widget tekst (eller grafik) skal placeres. Anvend en af N, NE,
E, SE, S, SW, W, NW, eller CENTER. CENTER er forvalgt. Du kan bruge
select_from metoden til at vælge en tekst.
</para>

<para>background (forkortelse bg)</para>

<para>Baggrundsfarve. Forvalgt er system afhængig (sædvanligvis hvid -
white). Hvis du ændrer baggrundsfarven, vil du som regel også skulle
skifte forgrundsfarve (foreground). Farveegenskaben er kun anvendelig p
text og bitmap widgets.
</para>

<para>Flgende bitmaps er tilgængelige på alle platforme:</para>

<para>error, gray75, gray50, gray25, gray12, hourglass, info, questhead,
question, og warning.</para>

<para>borderwidth (forkortelse: bd)</para>

<para>Kant bredde. Den forvalgte værdi er 0. borderwidth = 2 (pixels)
vil ofte passe godt.</para>

<para>command</para>

<para>
Når der klikkes på f.eks. en knap kaldes (køres/afvikles) command
metoden, der selv kalder en såkaldt callback, der kan være en funktion,
en bundet metode eller et hvilket som helst andet kaldbart Python objekt.
</para>

<para>cursor</para>
<para>Markør der vises, hvis musemarkøren befinder sig over widget.</para>

<para>delete(indeks)</para>
<para>Sletter tegnet på indeks' plads.</para>

<para>delete(fra,til)</para>
<para>Sletter teksten i det valgte område. delete(0, END) sletter hele
teksten i widget.</para>

<para>disabledforeground</para>
<para>Farven, der bruges, når widget er inaktiv (disabled).Baggrunden
vises i background color.</para>

<para>END (eller  "end")</para>
<para>Angiver positionen lige bag det sidste tegn i widget. Teksten
i omrdet (0, END) er den fulde tekst i widget.</para>

<para>exportselection</para>
<para>Hvis sand (true), eksporteres den valgte tekst automatisk til
clipboard (her er vist ingen klar dansk betegnelse - et sted udenfor
Python miljøet er clipbord blevet kaldt udklipsholder). Forvalgt er
sand (true).</para>

<para>font</para>
<para>Skriften/skrifterne der anvendes i widget. Den forvalgte skrift
afhænger af widget og af styresystemet.</para>

<para>foreground (fg)</para>
<para>Forgrundsfarve især farven på tekst.</para>

<para>geometry( "længde x bredde" )</para>
<para>Metode der konfigurerer længde og bredde af moder komponenten målt
i antal pixels. eks. self.master.geometry( "325x100" )</para>

<para>get() => streng</para>
<para>Returnerer streng, hvor streng er den aktuelle tekst i Entry.</para>

<para>highlightbackground, highlightcolor</para>
<para>Kontrollerer hvordan Entrys yderkant (border) skal tegnes. Når
widget er valgt (has focus), tegnes yderkanten med highlightcolor
farven. Ellers tegnes den med highlightbackground farven. Den forvalgte
farve er systemafhængig.</para>

<para>highlightthickness</para>
<para>Kontrollerer bredden på et markeret (highlighted) område. Forvalgt
er typisk en eller to pixels.Forvalgt er 0 pixels (ingen kant).</para>

<para>icursor(indeks)</para>
<para>flytter markøren (the insertion cursor) til det givne indeks.
Dette sætter også INSERT indeks.</para>

<para>
image</para><para>
Egenskaben kan vise image i en label. Den har højere prioritet end text og bitmap egenskaberne, så de kan ikke vises, når image er valgt.
</para>
<para>Index</para><para>
Indeks fungerer helt som i Python lister. Karaktererne i en tekststreng er nummererede fra 0 til og opad. Du specificerer ranges helt som du slice lister i Python (slicing er behandlet tidligere i bogen) f.eks. svarer (0, 5) til de første 5 tegn i en widget.
</para>
<para>
indicatoron</para><para>
Kontrollerer hvorvidt indikatoren skal tegnes eller ikke. Forvalgt er on. Hvis knappen vælges, tegnes den som
SUNKEN (nedtrykt) ellers som RAISED.
</para>
<para>
INSERT (eller "insert")</para><para>
Markeres ved tekstmarkørens blinken på stedet, Metoden icursor kan benyttes til fra programmet at ændre indsættelsespunktet.
Endelig kan du bruge musemarkørens indeks position v.h.a. syntaksen: "@%d" % x, hvor x er angivet i antal pixels fra venstre side af entry widget.
</para>
<para>
insertbackground</para><para>
Indsæt-markørens farvefarve.
</para>
<para>
insertborderwidth</para><para>
Kantbredde på indsæt-markøren
</para>
<para>
insertofftime, insertontime</para><para>
Kontrollerer markørens blinke frekvens.
</para>
<para>
insertwidth</para><para>
Indsæt-markørens bredde.
</para>
<para>
justify</para><para>
Placerer en flerlinjet tekst venstrejusteret justify = LEFT, højrejusteret justify = RIGHT eller centreret  justify = CENTER.
</para>
<para>
onvalue og offvalue, </para><para>
Værdierne betyder valgt og ikke valgt. De booleske værdier er 0 og 1.
</para>
<para>
padx, pady</para><para>
Indrykning af tekst eller image i forhold til widgets ydre kant (border).
</para>
<para>
relief</para><para>
Kant dekoration (Border decoration). Den forvalgte værdi er  FLAT.  Andre mulige værdier er SUNKEN, RAISED, GROOVE, and RIDGE. BEMÆRK: For at ændre kantdekorationen fra dets forvalgte værdi (FLAT), er det nødvendigt at ændre dens borderwidth fra dens forvalgte værdi 0 (ingen kantbredde). eks.  borderwidth = 2, relief = RIDGE
</para>
<para>
Scan metoderne kan implementere hurtige museoperationer (de er tilknyttet midterste museknap, hvis en sådan er tilgængelig), hvor xview metoden anvendes sammen med en standard scrollbar widget.
</para>
<para>
scan_mark(x)</para><para>
Sætter scanning anchor for hurtig vandret rulning til den givne muse koordinat.
</para>
<para>
scan_mark(x, y)</para><para>
scan_mark sætter scanning anchor for hurtig vandret rulning til de givne musekoordinater.
</para>
<para>
scan_dragto(x)</para><para>
Ruller Entrys indhold sidevis svarende til den givne muse koordinat, Teksten flyttes 10 gange afstanden mellem
den givne afstand mellem scanning anchor og den nye position.
</para>
<para>
select_adjust(indeks) og selection_adjust(indeks)</para><para>
Juster den aktuelle tekst til også at omfatte tegnet på plads indeks. Hvis det givne indeks allerede er valgt gres ingen ting.
</para>
<para>
selectbackground</para><para>
Valg baggrundsfarve. Den forvalgte er skærmafhængig
</para>
<para>
selectborderwidth</para><para>
Vælg kantbredde. Den forvalgte er systemafhængig.
</para>
<para>
selection_from(indeks), select_from(indeks)</para><para>
Indleder et nyt valg. Sætter også ANCHOR indeks.</para><para>
def selection_from(text, index):</para><para>
        text._anchor = index
</para>
<para>
selection_present() => flag, select_present() => flag</para><para>
Returnerer sand (true (ikke nul)), hvis en del af en tekst er valgt.</para><para>
def selection_present(text):</para><para>
        return len(text.tag_ranges(SEL)) != 0
</para>

<para>
selectcolor</para><para>
Farve til brug på selector f.eks. knap.
</para>
<para>
selectforeground</para><para>
Vælg tekstfarve. Den forvalgte er system- og skærmafhængig.
</para>
<para>
selection_clear(), select_clear()</para><para>
Slet den valgte tekst.</para><para>
def selection_clear(text):</para><para>
        text.tag_remove(SEL, 1.0, END)
</para>
<para>
selectimage</para><para>
Image til brug sammen med selector.
</para>
<para>
selection_range(start, slut), select_range(start,slut)</para><para>
Vælger tekst i Entry widget. start skal naturligvis være større end slut.
</para>
<para>
selection_range(0, END)</para><para>
Vælger hele teksten.</para><para>
def selection_range(text, start, end):</para><para>
        text.tag_remove(SEL, 1.0, start)</para><para>
        text.tag_add(SEL, start, end)</para><para>
        text.tag_remove(SEL, end, END)
</para>
<para>
select_to(indeks), selection_to(indeks)</para><para>
Vælger hele teksten mellem ANCHOR og det givne indeks.</para><para>
def selection_to(text, index):</para><para>
        if text.compare(index, "&lt;", text._anchor):</para><para>
            selection_range(text, index, text._anchor)</para><para>
        else:</para><para>
            selection_range(text, text._anchor, index)
</para>

<para>
setgrid </para><para>
Hvis sand (true) forsøger Tkinter at ændre størrelsen af vinduet med text widget i fulde tegn trin ud fra skriftens muligheder.
</para>
<para>
spacing1</para><para>
Pladsen (afstanden) over den første linje i en tekstblok. Forvalgt er 0 (ingen ekstra plads).
</para>
<para>
spacing2</para><para>
Pladsen (afstanden) mellem linjerne  i en tekstblok. Forvalgt er 0 (ingen ekstra plads).
</para>
<para>
spacing3</para><para>
Pladsen (afstanden) efter den sidste linje i en tekstblok. Forvalgt er 0 (ingen ekstra plads).
</para>
<para>
show</para><para>
Controls how to display the contents of the widget. If non-empty, the widget displays a string of characters instead of the actual contents. To get a password entry widget, use "*".
</para>
<para>
state</para><para>
Bestemmer hvorvidt bruger skal kunne ændre indholdet i widget eller ikke. Mulighederne er NORMAL (bruger har fuld adgang til at ændre indholdet i widget) og DISABLED (bruger kan ikke ændre indholdet i widget). NORMAL er forvalgt. Eks. entry.config(state = DISABLED )
</para>
<para>
tag_bind binder en hændelse (event) til en given funktion.</para><para>
tag_bind(tag, sekvens, funktion) og tag_bind(tag, sekvens, funktion, "+")</para><para>
Tag bindinger kan anvende muse- og tastatur-relaterede hændelser plus
&lt;Enter&gt; og &lt;Leave&gt;. Hvis ikke styrekoden eksisterer, oprettes den. Sædvanligvis vil en ny binding erstatte alle bindinger for den samme hændelses frekvens. Den sidste form kan anvendes for at føje en ny callback til den eksisterende binding.
</para>
<para>
tag_cget(tag, option)</para><para>
Henter den aktuelle værdi for den givne option (egenskab).
</para>
<para>
tag_config()</para><para>
Egenskaber (options) kan indsættes med tag_config:</para><para>
tag_config() udstyrer widget med en eller flere egenskaber eks. text.config(bg="red", fg="white") her tildeles text egenskaben at kunne skrive tekst med rød baggrund og hvid skrift.
</para>
<para>
tag_delete(tag)</para><para>
Tags kan fjernes med:</para><para>
tag_delete(tag), tag_delete(tags...). eks. text.tag_delete(bg)
</para>
<para>
tag_names()</para><para>
Returnerer en tuple indeholdende  alle tags, der anvendes i widget.
</para>
<para>
tag_names(index)</para><para>
Returnerer en tuple indeholdende alle tags anvendt af tegnet på den givne position.
</para>
<para>
tag_nextrange(tag, index), tag_nextrange(tag, start, stop)</para><para>
Finder den næste af en given tag startende fra det givne index. Hvis 2 indekser er givet eks. start, stop søges kun fra start til stop.
</para>
<para>
tag_prevrange(tag, index), tag_prevrange(tag, start, stop)</para><para>
Som tag_nextrange, men søger tilbage i teksten.
</para>
<para>
tag_remove og tag_unbind kan fjerne bindinger:</para><para>
tag_unbind(tag, sekvens). Fjerner bindingen, hvis der er en sådan.
</para>
<para>
takefocus</para><para>
Giver brugeren mulighed for at anvende tabulatortasten for at vælge widget. En tom streng er forvalgt.
</para>
<para>
text </para><para>
Egenskaben kan vise tekst i widget. Teksten kan omfatte "\n" ny linje. Hvis bitmap eller image egenskaben bruges ignoreres text egenskaben.
</para>
<para>
textvariable</para><para>
Forbinder en Tkinter variabel (sædvanligvis en StringVar) med labelen. Hvis variablen ændres opdates teksten i label. Eks. textvariable = self.entry(fg = "green")
</para>
<para>
toggle()</para><para>
Fastholder den valgte state (vedr. state se under generelle egenskaber i indledningen til Widget klassen).
</para>
<para>
underline</para><para>
Understreg tekst forvalgt er -1, der betyder at ingen tekst er understreget.
</para>
<para>
width og height</para><para>
Bredde og højde egenskaberne kan initialiseres, men de behøver det ikke nødvendigvis Hvis ikke egenskaberne
tildeles direkte,  tildeles de automatisk efter indholdet i label.
</para>
<para>
wraplength</para><para>
Holder styr på hvornår der skal indsætte linjeskifte i en tekst. Forvalgt er ingen linjeskifte.wraplength sættes til screen units - normalt antal pixels.
</para>
<para>
xscrollcommand</para><para>
Kommando for rulning af selve widget.
</para>
<para>
xview(), yview()</para><para>
Returnerer en tuple indeholdende 2 værdier. Den første værdi svarer til den relative offset (startpunktet)
for den første synlige linje (søjle/column), og den anden værdi svarer til til den relative offset for linjen lige efter den sidste synlige linje på skærmen. Offset 0.0 begyndelsen af linjen, 1.0 slutningen.
</para>
<para>
xview(indeks)</para><para>
Kontroller om den givne indeks er synlig. Widget rulles om nødvendigt
</para>
<para>
xview(MOVETO, offset) og yview(MOVETO, offset)</para><para>
Flytter text widget, således at det givne udgangspunkt (offset) er i øverste venstre  hjørne
Offset 0.0 markerer tekstens begyndelse, 1.0 slutningen. Metoderne her bruges af
Scrollbar bindinger, når brugeren  flytter knappen i rulleskakten.
</para>
<para>
xview(SCROLL, trin, emne), yview(SCROLL, trin, emne)</para><para>
Ruller widget vandret i det givne trin. Emnet, der skal flyttes,kan være UNITS (linjer og tegn) eller PAGES (sider). Metoderne her bruges af Scrollbar bindinger, når brugeren flytter rulleskaktens skyder.scan metoderne er bundet til midterste museknap, mens xview og yview metoderne bruges sammen med standard scrollbars.
</para>

<para>
 Label underklasse i Widget
</para>

<programlisting>
from Tkinter import *
root = Tk()
skrift = ("times", 20, "bold")
label = Label(root, text="Der kan skrives på en label.")
label.config(bg="black", fg="white")
label.config(font=skrift)
label.config(height=4, width=30)  # plads til 4 linjer a 30 tegn
label.pack(expand=YES, fill=BOTH)
root.mainloop()
</programlisting>

<programlisting>
from Tkinter import *
# label1, label2 og label3 arver Label klassen med dens pack funktion (metode)
label1 = Label(text ="Enkelt, men omfattende.").pack(expand = NO, side = LEFT)
label2 = Label(text ="Lige i centrum.").pack(expand = NO, side = TOP)
label3 = Label(text ="Total trods enkel.").pack(expand = NO, side = RIGHT)
mainloop()
</programlisting>

<para>
eller f.eks. :
</para>

<programlisting>
from Tkinter import *
class LabelDemo( Frame ):

   def __init__( self ):  # LabelDemos konstruktr

      Frame.__init__( self )   # mor Frames konstruktr

      self.pack( expand = YES, fill = BOTH )
      self.master.title( "Labels" )

      self.label1 = Label( self, text = "Label med tekst" )
      self.label1.pack()

      self.label2 = Label( self,
         text = "Label med tekst og bitmap" )
      self.label2.pack( side = LEFT )
      self.label3 = Label( self, bitmap = "questhead" )
      self.label3.pack( side = LEFT )

def main():
   LabelDemo().mainloop()

if __name__ == "__main__": main()
</programlisting>

<figure float="1"><title>Titel</title><graphic fileref="w2_2.&magic;" scale="40"></graphic></figure>

<para>Entry underklasse i Widget</para>
<para>Entry er et en-linjes input område, der kan modtage input fra tastaturet eller vise information.
Entry widgetten giver dig mulighed for at placere tegn på en række forskellige måder.
</para>
<programlisting>
from Tkinter import *
root = Tk()
class SkriftKontrol( Frame ):
   def __init__( self ):
      Frame.__init__( self )
      self.pack( expand = YES, fill = BOTH )
      self.master.title( "Entry og Checkbutton demo" )

      self.frame1 = Frame( self )
      self.frame1.pack()

      self.entry = Entry( self.frame1, width = 40,
         font = "Times 12" )
      self.entry.insert( INSERT, "Bemærk hvordan skriften ændres" )
      self.entry.pack( padx = 5, pady = 5 )

      self.frame2 = Frame( self )
      self.frame2.pack()

      # opret boolsk variable til fed skrift
      self.fedValgt = BooleanVar()

      self.kontrolFed = Checkbutton( self.frame2, text = "Bold",
         variable = self.fedValgt, command = self.skiftSkrift )
      self.kontrolFed.pack( side = LEFT, padx = 5, pady = 5 )

      # opret boolsk variable til skråskrift
      self.skraaValgt = BooleanVar()

      self.kontrolSkraa = Checkbutton( self.frame2,
         text = "Italic", variable = self.skraaValgt,
         command = self.skiftSkrift )
      self.kontrolSkraa.pack( side = LEFT, padx = 5, pady = 5 )

   def skiftSkrift( self ):
	valgteSkrift = "Times 12"

      	if self.fedValgt.get():
         	valgteSkrift += " bold"

      	if self.skraaValgt.get():
         	valgteSkrift += " italic"

      	self.entry.config( font = valgteSkrift )

def main():
   SkriftKontrol().mainloop()

if __name__ == "__main__": main()
</programlisting>

<figure float="1"><title>Titel</title><graphic fileref="w3_1.&magic;" scale="40"></graphic></figure>

<programlisting>
from Tkinter import *
from tkMessageBox import *

class EntryDemo( Frame ):
   def __init__( self ):
      Frame.__init__( self )
      self.pack( expand = YES, fill = BOTH )
      self.master.title( "Test datamodtagere" )
      self.master.geometry( "325x100" )

      self.frame1 = Frame( self )
      self.frame1.pack( pady = 5 )
      # text1 oprettes som barnebarn af Frame
      # entry er endnu en underklasse i Widget klassen (ls barn af)
      self.text1 = Entry( self.frame1, name = "tekst1" )
      self.text1.bind( "&lt;Return&gt;", self.visIndhold )
      self.text1.pack( side = LEFT, padx = 5 )

      self.text2 = Entry( self.frame1, name = "tekst2" )
      self.text2.insert( INSERT, "Skriv tekst her" )
      self.text2.bind( "&lt;Return&gt;", self.visIndhold )
      self.text2.pack( side = LEFT, padx = 5 )

      self.frame2 = Frame( self )
      self.frame2.pack( pady = 5 )

      self.text3 = Entry( self.frame2, name = "tekst3" )
      self.text3.insert( INSERT, "Ikke editerbar tekstboks" )
      self.text3.config( state = DISABLED )
      self.text3.bind( "&lt;Return&gt;", self.visIndhold )
      self.text3.pack( side = LEFT, padx = 5 )

      self.text4 = Entry( self.frame2, name = "tekst4",show = "*" )
      self.text4.insert( INSERT, "Hemmelig tekst" )
      self.text4.bind( "&lt;Return&gt;", self.visIndhold )
      self.text4.pack( side = LEFT, padx = 5 )

   def visIndhold( self, event ):
      navn = event.widget.winfo_name()
      indhold = event.widget.get()
      showinfo( "Melding", navn + ": " + indhold )

def main():
   EntryDemo().mainloop()

if __name__ == "__main__":main()
</programlisting>

<figure float="1"><title>Titel</title><graphic fileref="w3_2.&magic;" scale="40"></graphic></figure>

<figure float="1"><title>Titel</title><graphic fileref="w4.&magic;" scale="40"></graphic></figure>

<para>Text underklasse i Widget
Område til flerlinjet input.Accepterer input fra tastatur og viser informationen. *
</para>
<programlisting>
from Tkinter import *

# Trin 1: Opret den applikations-klasse (program-klasse), hvori GUI
# og hændelses-metoder (event handling methods) defineres
class Klasse(Frame):
	def __init__(self):
		Frame.__init__(self)
		self.tekstboks = Text(self)
		self.tekstboks.bind("&lt;space&gt;", self.Afslut)
		self.tekstboks.bind("&lt;Key&gt;", self.modtagTastensNummer)
		self.tekstboks.pack()
		self.pack()

	def Afslut(self,event):
		import sys
		sys.exit()

	def modtagTastensNummer(self,event):
		str = "%d\n" % event.keycode
		self.tekstboks.insert(END, str)
		return "break"

# Opret arving og start hændelsesløkken
barn = Klasse()
barn.mainloop()
</programlisting>

<figure float="1"><title>Titel</title><graphic fileref="w4_2.&magic;" scale="40"></graphic></figure>

<programlisting>
from Tkinter import *
root = Tk()
def melding(event): print "Modtog melding om klik på knap"

text = Text()
text.config(font=("times", 18, "normal"))    # skrift 18 punkts normal
text.config(height=40, width=60)            # plads til 40 linjer a 60 tegn
text.pack(expand=YES, fill=BOTH)
text.insert(END, "Dette er\n\nmeningen\n\nmed livet.\n\n")   # indsætter 6 linjer

#linje 1  sender "Modtog melding om klik på knap" til skal (shell)
knap = Button(text, text="Python er andet end slanger.", command=lambda:melding(1))
knap.pack()
text.window_create(END, window=knap)    # indsætter foto
text.insert(END, "\n\n")

foto  = PhotoImage(file="skyer.gif")
text.image_create(END, image=foto)
root.mainloop()
</programlisting>

<figure float="1"><title>Titel</title><graphic fileref="w4_3.&magic;" scale="40"></graphic></figure>

<para>Button underklasse i Widget</para>
<para>
Button (knap) er fordefineret som et komponent tilhørende Widget.
Ved klik på knappen med musens markør kan f.eks. funktion (metode) kaldes.</para>
<programlisting>
from Tkinter import *
def f(): print "Hej! Jeg er her."
Button(text = "Funktionskald", command = f()).pack( pady = 5 )
Hej! Jeg er her. udskrives i skal (shell)
</programlisting>

<programlisting>
import sys
from Tkinter import *
widget = Button(None, text='Afslut', command=sys.exit)
widget.pack()
widget.mainloop()

from Tkinter import *

class Arving(Frame):   # Klassehovede Arving er barn af  Frame
    def __init__(Arving, mor=None):
        Frame.__init__(Arving, mor)   # initialiser superklasse (superclass)
        Arving.pack()
        Arving.data = 10
        Arving.opret_arvinger() # Forener barn med mor

    def opret_arvinger(Arving):
        widget = Button(Arving, text='Knaptekst!', command=Arving.message)
        widget.pack(side=LEFT)

    def message(Arving):
        Arving.data = Arving.data + 1
        print 'Sum %s' % Arving.data # udskriver på skal (kunne være til fil)

if __name__ == '__main__': Arving().mainloop()
</programlisting>

<figure float="1"><title>Titel</title><graphic fileref="w5_3.&magic;" scale="40"></graphic></figure>

<programlisting>
from Tkinter import *

def quit():             # callback handler
    print 'Afslut'      # skriver til skal (shell)
    import sys; sys.exit()

knapBarn = Button(None, text='Afslut', command=quit)
knapBarn.pack()
knapBarn.mainloop()
</programlisting>

<figure float="1"><title>Titel</title><graphic fileref="w5.&magic;" scale="40"></graphic></figure>

<programlisting>
from Tkinter import *

class Arving(Frame):   # Klassehovede Arving er barn af  Frame
    def __init__(Arving, mor=None):
        Frame.__init__(Arving, mor)   # initialiser superklasse (superclass)
        Arving.pack()
        Arving.data = 10
        Arving.opret_arvinger()             # forener arvinger med mor
    def opret_arvinger(Arving):
        widget = Button(Arving, text='Knaptekst!', command=Arving.message)
        widget.pack(side=LEFT)
    def message(Arving):
        Arving.data = Arving.data + 1
        print 'Sum %s' % Arving.data # udskriver på skal (kunne være til fil)

if __name__ == '__main__': Arving().mainloop()
</programlisting>

<para>Eksempel på brugerdialog</para>
<programlisting>
from Tkinter import *

class dialog:
    def __init__(self, parent):
        top = self.top = Toplevel(parent)
        Label(top, text="Indskriv").pack()
        self.e = Entry(top)
        self.e.pack(padx=5)

        b = Button(top, text="OK", command=self.ok)
        b.pack(pady=5)

    def ok(self):
	# Value er fordefineret
        print "Value er", self.e.get()

        self.top.destroy()

root = Tk()
Button(root, text="Hej!").pack()
root.update()

d = dialog(root)

root.wait_window(d.top)
</programlisting>

<figure float="1"><title>Titel</title><graphic fileref="w5_5.&magic;" scale="40"></graphic></figure>

<programlisting>
from Tkinter import *

class knapRamme( Frame ):
   def __init__( self ):
      Frame.__init__( self )
      self.master.title( "Knap oprettelse" )
      self.master.geometry( "400x150" )
      self.pack( expand= YES, fill = BOTH )

      self.knap1 = Button( self, text = "Opret ny knap",
         command = self.opretNyKnap ) # funktions kald
      self.knap1.pack( side = TOP )

      self.knap2 = Button( self,text = "expand= NO, fill = BOTH" )
      self.knap2.pack( side = BOTTOM, fill = BOTH )

      self.knap3 = Button( self,text = "expand= YES, fill = X" )
      self.knap3.pack( side = LEFT, expand= YES, fill = X )

      self.knap4 = Button( self,text = "expand= YES, fill = Y" )
      self.knap4.pack( side = RIGHT, expand= YES, fill = Y )

   def opretNyKnap( self ):
      Button( self, text = "Ny knap" ,bg = "green", fg = "red" ).pack( pady = 5 )

def main():knapRamme().mainloop()

if __name__ == "__main__": main()
</programlisting>

<figure float="1"><title>Titel</title><graphic fileref="w5_6.&magic;" scale="40"></graphic></figure>

<para>Checkbutton underklasse i Widget</para>
<para>
Kontrolknap der kan være til- eller fravalgt.
For at kunne bruge en Checkbutton, må du oprette en Tkinter variabel:
<programlisting>
var = IntVar()
kontrolknap = Checkbutton(master, text="Udvid", v = var)
</programlisting>
var er forvalgt tildelt værdien 1, hvis knappen er valgt ellers 0. Du kan om ønsket ændre disse værdier. I så fald skal du bruge onvalue og offvalue egenskaberne. Variablen behøver ikke være en heltals variabel.
</para>
<programlisting>
    var = StringVar()
    kontrolknap = Checkbutton(
        master, text="Jeg er til farve", variable= var,
        onvalue="RGB", offvalue="L"
        )
</programlisting>
<para>
Hvis du har brug for at holde styr på både variabel og widget, kan du simplificere koden noget ved at knytte
variablen til arvingen (the widget reference object).
</para>
<programlisting>
    v = IntVar()
    kontrolknap = Checkbutton(master, text="Vis ikke denne igen", variable=v)
    kontrolknap.var = v
</programlisting>
<para>
Hvis den Tkinter kode allerede befinder sig i en klasse (hvad den bør gøre), så er det ligesom renere at
placere variablen i en attribut og anvende en bundet metode som callback (i eksemplet forkortet til cb):
</para>
<programlisting>
    def __init__(self, master):
        self.var = IntVar()
        kontrolknap = Checkbutton(master, text="Enable Tab",
                        variable=self.var, command=self.cb)
        kontrolknap.pack()

    def cb(self, event):
        print "variablen er", self.var.get()
</programlisting>

<programlisting>
from Tkinter import *
def f(): print "Hej! her går det godt!"
Checkbutton(text = "Klik på mig", command = f())
</programlisting>

<screen>
<userinput>python test.py</userinput>
Hej! her går det godt!
</screen>

<para>
Se også det ret store eksempel på brugen af Entry og Checkbutton, som
tidligere er benyttet.
</para>

<para>Radiobutton underklasse i Widget</para>

<para>
En Radiobutton widget ligner langt hen ad vejen en Checkbutton
widget. For at få radioknappen til at opføre sig ordentlig, må du lade
alle knapper i en gruppe pege til den samme variabel og bruge den
samme value egenskab til specifikation af hvad den enkelte knap
reprsenterer.
</para>

<programlisting>
 v = IntVar()
    Radiobutton(master, text="En", variable=v, value=1).pack(anchor=W)
    Radiobutton(master, text="To", variable=v, value=2).pack(anchor=W)
</programlisting>

<para>
Hvis du har brug for en tydeliggørelse af hvad det medfører, når en value
ændres, kan der indsættes en command callback til den enkelte knap
</para>

<programlisting>
 Radiobutton(master, text="En", variable=v, value=1, command = funktionskald).pack(anchor=W)
</programlisting>

<para>
 For at oprette et stort antal knapper kan der anvendes en loop
</para>

<programlisting>
    MODES = [
        ("Monochrome", "1"),
        ("Grayscale", "L"),
        ("True color", "RGB"),
        ("Color separation", "CMYK"),
    ]

    v = StringVar()
    v.set("L") # initialiser

    for text, mode in MODES:
        b = Radiobutton(master, text=text,variable=v, value=mode)
        b.pack(anchor=W)
</programlisting>

<para>
For at ændre det ovenstående eksempel til en "button box", skal
v.set("L") ændres til v.set("O").
</para>

<programlisting>
from Tkinter import *
root = Tk()
var  = IntVar()
for i in range(10):
    radioknap= Radiobutton(root, text=str(i), value=i, variable=var)
    radioknap.pack(side=LEFT)
root.mainloop()
print var.get()
</programlisting>

<programlisting>
from Tkinter import *
root = Tk()

def funktion():
	return 12 ** 2 # returnerer til skal (shell)

var = StringVar()
for i in range(6):
    radioknap= Radiobutton(root, text= "Knap " + str(i),bg = "blue", fg = "yellow", 		value=i, variable=var, command = funktion)
    radioknap.pack(side = TOP)
root.mainloop()
print var.get()
</programlisting>

<figure float="1"><title>Titel</title><graphic fileref="w7_5.&magic;" scale="40"></graphic></figure>

 <para>
  Menu underklasse i Widget Menu komponenten kan vise en liste af
  værdier, hvorfra brugeren kan vælge.  I Tkinter er der en fordefineret
  widget for menuer. Når du ønsket at oprette en menu, begynder du med
  at oprette en arving til Menu klassen, hvorefter du anvender add
  metoder for at tilføje indgange (entries) til den.
</para>

<para>
 add_command(label=streng, command=callback) indsætter en almindelig
 menu indgang.  add_separator() indsætter separator linje. Den benyttes
 til at adskille indgange, så oversigten forbedres.
 add_cascade(label=streng, menu=menu instance) tilfjer endnu en menu,
 der enten kan være en pull-down menu eller en fold-out menu.
</para>

<programlisting>
import sys
from Tkinter import *
win = Tk()
menulinje = Menu(win)
win.config(menu = menulinje)
filmenu = Menu(menulinje)
menulinje.add_cascade(label = "Filer", menu = filmenu)

def udskriv(): print "Udskriv data"
def gem(): print "Gem fil"

filmenu.add_command(label = "Udskriv", command = udskriv)
filmenu.add_command(label = "Gem", command = gem)
filmenu.add_separator()
filmenu.add_command(label = "Afslut", command = sys.exit)
win.mainloop()

v = IntVar()
filmenu.add_radiobutton(label = "Udskriv", var = v, value = 1
filmenu.add_radiobutton(label = "Gem", var = v, value = 2
filmenu.add_radiobutton(label = "Afslut", var = v, value = 3

v = IntVar()
filmenu.add_checkbutton(label = "Hent", var = v, command = hent)
</programlisting>

<para>
I det følgende eksempel skal vi se på en pupop menu og p, hvordan vi kan
vælge farve fra den som baggrundsfarve til vinduet.
</para>

<programlisting>
from Tkinter import *
class PopupMenuDemo( Frame ):
   def __init__( self ):
      Frame.__init__( self )
      self.pack( expand = YES, fill = BOTH )
      self.master.title( "Popup menu demo" )
      self.master.geometry( "350x250" )
      self.frame = Frame( self, bg = "green" )
      self.frame.pack( expand= YES, fill = BOTH )

      self.menu = Menu( self.frame, tearoff = 0 )
	# De engelske farvenavne her bruges til farveskifte
      farver = [ "yellow", "green", "red", "blue", "grey" ]
      self.selectedColor = StringVar()
      self.selectedColor.set( farver[ 0 ] )

      for item in farver:
         self.menu.add_radiobutton( label = item,
            variable = self.selectedColor,
            command = self.skiftBaggrundsfarve )
      # BEMRK her bruges midterste museknap
      self.frame.bind( "&lt;Button-2&gt;", self.popUpMenu )

   def popUpMenu( self, event ):
      self.menu.post( event.x_root, event.y_root )

   def skiftBaggrundsfarve( self ):
      self.frame.config( bg = self.selectedColor.get() )

def main():
   PopupMenuDemo().mainloop()

if __name__ == "__main__":
   main()
</programlisting>

<figure float="1"><title>Titel</title><graphic fileref="w8_5.&magic;"
scale="40"></graphic></figure>

 <para>
  I det følgende eksempel skal vi bl.a. se på integreringen af en
  hjælpemenu Vi begynder med at oprette en arving til Menu, hvorefter
  vi benytter config metoden til at knytte den til root
  vinduet. Indholdet af den menu bruges til oprettelse af en menulinje
  verst i root vinduet. Det er unødvendigt at pakke menuen, da den
  styres automatisk af Tkinter.
</para>

<para>
 Det næste trin er oprettelse af en ny Menu arving. Hertil benyttes
 menulinjen som widget mor og add_cascade metoden går den til en
 pulldown menu. Nu er vi klar til at kalde add_command og tilføje
 kommandoer til menuen og slutte af med at kalde add_separator for at
 adskille filkommandoerne og Afslut kommandoen og endelig at indsætte
 en hjlpemenu. Metoden Python kan naturligvis udskiftes med relevante
 metoder. Her benyttes den alene for at kunne få command i funktion.
</para>

<programlisting>
from Tkinter import *
root = Tk()

def Python():
    print "Jeg er Mr Python!"

menu = Menu(root)
root.config(menu=menu)

filmenu = Menu(menu)
menu.add_cascade(label="Filer", menu=filmenu)
filmenu.add_command(label="Ny", command=Python)
filmenu.add_command(label="bn...", command=Python)
filmenu.add_separator()
filmenu.add_command(label="Afbryd", command=Python)

helpmenu = Menu(menu)
menu.add_cascade(label="Hjlp", menu=helpmenu)
helpmenu.add_command(label="Om projektet...", command=Python)

mainloop()
</programlisting>

<figure float="1"><title>Titel</title><graphic fileref="w8.&magic;"
scale="40"></graphic></figure>

<para>Canvas underklasse i Widget</para>

<para>
 Her er for en gang skyld en widget med et navn, der staves ens p
 engelsk og på dansk. Begrebet canvas findes i flere computersprog, men
 hvad dækker det over? Ganske enkelt det, det hedder. Canvas er noget
 meget groft lærred, som bl.a. bruges til at udfre malerier på - altså
 noget til at tegne og male på. Sådan er det i virkeligheden og sådan er
 det, når begrebet overflyttes til et computersprog også Python.
</para>

<programlisting>
from Tkinter import *
root = Tk()
Canvas(root,bg = "light green").pack(expand = YES, fill = BOTH)
root.mainloop()
</programlisting>

<programlisting>
from Tkinter import *
class klatmaleren( Frame ):

   def __init__( self ):
      Frame.__init__( self )
      self.pack( expand = YES, fill = BOTH )
      self.master.title( "Et meget simpelt maleprogram" )
      self.master.geometry( "350x250" )

      self.message = Label( self, text = "Flyt musen og tegn" )
      self.message.pack( side = BOTTOM )

      self.canvas = Canvas( self )
      self.canvas.pack( expand = YES, fill = BOTH )

      # bind flyt mus til Canvas
      self.canvas.bind( "&lt;B1-Motion&gt;", self.paint )

   def paint( self, event ):
      """Tegn en oval med radius 1  den er stregtykkelsen"""

      x1, y1 = ( event.x - 1 ), ( event.y - 1 )
      x2, y2 = ( event.x + 1 ), ( event.y + 1 )
      self.canvas.create_oval( x1, y1, x2, y2, fill = "red" )

def main():
   klatmaleren().mainloop()

if __name__ == "__main__": main()
</programlisting>

<figure float="1"><title>Titel</title><graphic fileref="w9_5.&magic;"
scale="40"></graphic></figure>

<programlisting>
from Tkinter import *
spor = 0

class KanvasEvents:
    def __init__(self, parent=None):
        canvasArving = Canvas(width=300, height=300, bg="light green")
        canvasArving.pack()
        canvasArving.bind("&lt;ButtonPress-1&gt;", self.Opstart)
        canvasArving.bind("&lt;B1-Motion&gt;",     self.slet_og_gentegn)
        canvasArving.bind("&lt;Double-1&gt;",      self.slet)
        canvasArving.bind("&lt;ButtonPress-3&gt;", self.flyt)
        self.canvasArving = canvasArving
        self.drawn  = None
        self.kinds = [canvasArving.create_oval, canvasArving.create_rectangle]

    def Opstart(self, event):
        self.shape = self.kinds[0]
        self.kinds = self.kinds[1:] + self.kinds[:1]
        self.start = event
        self.drawn = None

    def slet_og_gentegn(self, event):
        canvasArving = event.widget
        if self.drawn: canvasArving.delete(self.drawn)
        objectId = self.shape(self.start.x, self.start.y, event.x, event.y)
        if spor: print objectId
        self.drawn = objectId

    def slet(self, event):
        event.widget.delete("all")

    def flyt(self, event):
        if self.drawn:
            if spor: print self.drawn
            canvasArving = event.widget
            diffX, diffY = (event.x - self.start.x), (event.y - self.start.y)
            canvasArving.move(self.drawn, diffX, diffY)
            self.start = event

if __name__ == "__main__":
    KanvasEvents()
    mainloop()
</programlisting>

<figure float="1"><title>Titel</title><graphic fileref="w9_1.&magic;"
scale="40"></graphic></figure>

<programlisting>
from Tkinter import *

canvas = Canvas(width=500, height=500, bg="light green")
canvas.pack(expand=YES, fill=BOTH)

canvas.create_line(100, 100, 200, 200)      # fraX, fraY, tilX, tilY
canvas.create_line(100, 200, 200, 300)      # tegn  geometr.  former
for i in range(1, 20, 2):
    canvas.create_line(0, i, 50, i)

canvas.create_oval(50, 50, 200, 200, width=2, fill="blue") # fraX, fraY, tilX, tilY
canvas.create_arc(200, 200, 300, 100) # fraX, fraY, tilX, tilY # fraX, fraY, tilX, tilY
canvas.create_rectangle(200, 200, 300, 300, width=5, fill="red") # fraX, fraY, tilX, tilY
canvas.create_line(50, 300, 150, 150, width=10, fill="grey")

foto=PhotoImage(file="skyer.gif")
canvas.create_image(350, 300, image=foto, anchor=NW)  # indst foto

label = Label(canvas, text="Python er for dig", fg="white", bg="black")
label.pack()

canvas.create_window(100, 100, window=label)        # indst en label
canvas.create_text(100, 280, text="og for mig")     # tegn noget tekst
mainloop()
</programlisting>

<figure float="1"><title>Titel</title><graphic fileref="w9.&magic;"
scale="40"></graphic></figure>

<para>Scale underklasse i Widget</para>

<programlisting>
from Tkinter import *
root = Tk()

def Metode():
	return "Metodekald"

skala = Scale(root, from_=-100, to=100, tickinterval=50, resolution=10)
skala.pack(expand=YES, fill=Y)

def metode(): print skala.get() #udskriver i skal (shell)

Button(root, text='status', command= Metode).pack(side=RIGHT)
root.mainloop()
</programlisting>

<figure float="1"><title>Titel</title><graphic fileref="w10_5.&magic;" scale="40"></graphic></figure>

<programlisting>
from Tkinter import *

class ScaleCanvasDemo( Frame ):
   def __init__( self ):
      Frame.__init__( self )
      self.pack( expand = YES, fill = BOTH )
      self.master.title( "Canvas og Scale widget demo" )
      self.master.geometry( "280x350" )

      # Opret Scale
      self.scale = Scale( self, from_ = 0, to = 300,
         orient = HORIZONTAL, command = self.opdaterCirkel )
      self.scale.pack( side = BOTTOM, fill = X )
      self.scale.set( 10 )

      # opret canvas og tegn cirkel
      self.canvas = Canvas( self, bg = "green" )
      self.canvas.pack( expand = YES, fill = BOTH )

   def opdaterCirkel( self, scaleValue ):
      """Slet cirklen, beregn ny størrelse og gentegn cirkel"""

      end = int( scaleValue ) + 10
      self.canvas.delete( "circle" )
      self.canvas.create_oval( 10, 10, end, end,
         fill = "blue", tags = "circle" )

def main():
   ScaleCanvasDemo().mainloop()

if __name__ == "__main__": main()
</programlisting>

<figure float="1"><title>Titel</title><graphic fileref="w10.&magic;" scale="40"></graphic></figure>

<para>Listbox underklasse i Widget</para>
<para>Listboksen kan vise en liste af tekststrenge,hvorfra der kan vælges.

Eksemplet viser en udvidet listeboks:
</para>

<programlisting>
from Tkinter import *

class Listeboks(Frame):
    def __init__(self, mor,elementer):
        Frame.__init__(self,mor)
        self.elementer = []
        for element,w in elementer:
            frame = Frame(self); frame.pack(side=LEFT, expand=YES, fill=BOTH)
            Label(frame, text=element, borderwidth=1, relief=RAISED).pack(fill=X)
            label = Listbox(frame, width=w, borderwidth=0, selectborderwidth=0,
                         relief=FLAT, exportselection=FALSE)
            label.pack(expand=YES, fill=BOTH)
            self.elementer.append(label)
            label.bind('&lt;B1-Motion&gt;', lambda e, s=self: s._select(e.y))
            label.bind('&lt;Button-1&gt;', lambda e, s=self: s._select(e.y))
            label.bind('&lt;Leave&gt;', lambda e: 'break')
            label.bind('&lt;B2-Motion&gt;', lambda e, s=self: s._b2motion(e.x, e.y))
            label.bind('&lt;Button-2&gt;', lambda e, s=self: s._button2(e.x, e.y))
        frame = Frame(self); frame.pack(side=LEFT, fill=Y)
        Label(frame, borderwidth=1, relief=RAISED).pack(fill=X)
        rulleskakt = Scrollbar(frame, orient=VERTICAL, command=self._scroll)
        rulleskakt.pack(expand=YES, fill=Y)
        self.elementer[0]['yscrollcommand']=rulleskakt.set

    def _select(self, y):
        row = self.elementer[0].nearest(y)
        self.selection_clear(0, END)
        self.selection_set(row)
        return 'break'

    def _button2(self, x, y):
        for element in self.elementer: element.scan_mark(x, y)
        return 'break'

    def _b2motion(self, x, y):
        for element in self.elementer: element.scan_dragto(x, y)
        return 'break'

    def _scroll(self, *args):
        for element in self.elementer:
            apply(element.yview, args)

    def curselection(self):
        return self.elementer[0].curselection()

    def slet(self, begynd, slut=None):
        for element in self.elementer:
            element.slet(begynd, slut)

    def hent(self, begynd, slut=None):
        result = []
        for element in self.elementer:
            result.append(element.hent(begynd,slut))
        if slut: return apply(map, [None] + result)
        return result

    def indeks(self, indeks):
        self.elementer[0].indeks(indeks)

    def insert(self, indeks, *elements):
        for e in elements:
            i = 0
            for element in self.elementer:
                element.insert(indeks, e[i])
                i = i + 1

    def size(self):
        return self.elementer[0].size()

    def see(self, indeks):
        for element in self.elementer:
            element.see(indeks)

    def selection_anchor(self, indeks):
        for element in self.elementer:
            element.selection_anchor(indeks)

    def selection_clear(self, begynd, slut=None):
        for element in self.elementer:
            element.selection_clear(begynd, slut)

    def selection_includes(self, indeks):
        return self.elementer[0].selection_includes(indeks)

    def selection_set(self, begynd, slut=None):
        for element in self.elementer:
            element.selection_set(begynd, slut)

if __name__ == '__main__':
    win = Tk()
    Label(win, text='Listeboks').pack()
    listeboks = Listeboks(win, (("Overskrift 1", 20), ("Overskrift  2", 10),
    ("Overskrift  3", 10)))

    listeboks.insert(END,("del 1", "del 2", "del 3"))
    listeboks.insert(END,("del 4", "del 5", "del 6"))
    listeboks.insert(END,("del 7", "del 8", "del 9"))
    listeboks.pack(expand=YES,fill=BOTH)
    win.mainloop()
</programlisting>

<figure float="1"><title>Titel</title><graphic fileref="w11.&magic;" scale="40"></graphic></figure>

<para>Scrollbar underklasse i Widget</para>
<para>Viser en rullemenu for canvasser, tekstbokse og lister</para>
<programlisting>
from Tkinter import *

class ScaleCanvasDemo( Frame ):
   def __init__( self ):
      Frame.__init__( self )
      self.pack( expand = YES, fill = BOTH )
      self.master.title( "Scale og Canvas demo" )
      self.master.geometry( "300x270" )

      self.control = Scale( self, from_ = 0, to = 300,
         orient = HORIZONTAL, command = self.updateCircle )
      self.control.pack( side = BOTTOM, fill = X )
      self.control.set( 10 )

      self.display = Canvas( self, bg = "navy" )
      self.display.pack( expand = YES, fill = BOTH )

   def updateCircle( self, scaleValue ):
      end = int( scaleValue ) + 10
      self.display.delete( "circle" )
      self.display.create_oval( 10, 10, end, end,
         fill = "red", tags = "circle" )

def main():
   ScaleCanvasDemo().mainloop()

if __name__ == "__main__":
   main()
</programlisting>

<figure float="1"><title>Titel</title><graphic fileref="w12_5.&magic;"
scale="40"></graphic></figure>

<para>
Menubutton underklasse i Widget
Menubutton viser popup eller pull-down menu.
</para>

<programlisting>
from Tkinter import *
root    = Tk()
menuknap = Menubutton(root, text='Byer')
picks   = Menu(menuknap)
menuknap.config(menu=picks)
picks.add_command(label='Hasle',  command=root.quit)
picks.add_command(label='Aakirkeby',  command=root.quit)
picks.add_command(label='Gudhjem', command=root.quit)
menuknap.pack()
menuknap.config(bg='white', bd=4, relief=RAISED)
root.mainloop()
</programlisting>

   <para>
    Optionmenu underklasse i Widget som menuknap, men viser valgmenu.

<programlisting>
from Tkinter import *
win = Tk()
var1 = StringVar()
var2 = StringVar()
opt1 = OptionMenu(win, var1, 'byer', 'Gudhjem',  'Tejn')
opt2 = OptionMenu(win, var2, 'erhverv',  'turisme', 'fiskeri')
opt1.pack(fill=X)
opt2.pack(fill=X)
var1.set('byer')
var2.set('erhverv')
def state(): print var1.get(), var2.get()
Button(win, command=state, text='Valgmenu').pack()
win.mainloop()
</programlisting>

   </para>
  </sect2>
 </sect1>
</chapter>
